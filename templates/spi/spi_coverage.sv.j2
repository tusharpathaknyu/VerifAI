//------------------------------------------------------------------------------
// SPI Coverage Collector
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef SPI_COVERAGE_SV
`define SPI_COVERAGE_SV

class spi_coverage extends uvm_subscriber #(spi_seq_item);
    
    `uvm_component_utils(spi_coverage)
    
    //--------------------------------------------------------------------------
    // Sampled Transaction
    //--------------------------------------------------------------------------
    spi_seq_item sampled_item;
    
    //--------------------------------------------------------------------------
    // Coverage Groups
    //--------------------------------------------------------------------------
    
    // Basic transaction coverage
    covergroup spi_transaction_cg;
        option.per_instance = 1;
        option.name = "spi_transaction_coverage";
        
        // Operation type
        cp_operation: coverpoint sampled_item.operation {
            bins write      = {SPI_WRITE};
            bins read       = {SPI_READ};
            bins write_read = {SPI_WRITE_READ};
        }
        
        // SPI mode coverage
        cp_mode: coverpoint sampled_item.mode {
            bins mode_0 = {SPI_MODE_0};
            bins mode_1 = {SPI_MODE_1};
            bins mode_2 = {SPI_MODE_2};
            bins mode_3 = {SPI_MODE_3};
        }
        
        // Slave selection
        cp_slave: coverpoint sampled_item.slave_select {
            bins slaves[] = {[0:SPI_NUM_SLAVES-1]};
        }
        
        // Bit order
        cp_bit_order: coverpoint sampled_item.bit_order {
            bins msb_first = {SPI_MSB_FIRST};
            bins lsb_first = {SPI_LSB_FIRST};
        }
        
        // Transfer width (for QSPI)
        cp_width: coverpoint sampled_item.width {
            bins single = {SPI_SINGLE};
            bins dual   = {SPI_DUAL};
            bins quad   = {SPI_QUAD};
        }
        
        // Cross coverage
        operation_x_mode: cross cp_operation, cp_mode;
        operation_x_slave: cross cp_operation, cp_slave;
        mode_x_slave: cross cp_mode, cp_slave;
    endgroup
    
    // Data pattern coverage
    covergroup spi_data_cg;
        option.per_instance = 1;
        option.name = "spi_data_coverage";
        
        // MOSI data patterns
        cp_mosi_value: coverpoint sampled_item.mosi_data {
            bins zero       = {0};
            bins all_ones   = { {SPI_DATA_WIDTH{1'b1}} };
            bins walking_1  = {8'h01, 8'h02, 8'h04, 8'h08, 8'h10, 8'h20, 8'h40, 8'h80};
            bins walking_0  = {8'hFE, 8'hFD, 8'hFB, 8'hF7, 8'hEF, 8'hDF, 8'hBF, 8'h7F};
            bins alternating = {8'h55, 8'hAA};
            bins low_nibble = {[8'h01:8'h0F]};
            bins high_nibble = {[8'hF0:8'hFE]};
            bins mid_range  = {[8'h10:8'hEF]};
        }
        
        // MISO data patterns
        cp_miso_value: coverpoint sampled_item.miso_data {
            bins zero       = {0};
            bins all_ones   = { {SPI_DATA_WIDTH{1'b1}} };
            bins low_nibble = {[8'h01:8'h0F]};
            bins high_nibble = {[8'hF0:8'hFE]};
            bins mid_range  = {[8'h10:8'hEF]};
        }
        
        // Cross MOSI and MISO patterns
        mosi_x_miso: cross cp_mosi_value, cp_miso_value {
            option.cross_auto_bin_max = 64;
        }
    endgroup
    
    // Timing coverage
    covergroup spi_timing_cg;
        option.per_instance = 1;
        option.name = "spi_timing_coverage";
        
        // Pre-delay coverage
        cp_pre_delay: coverpoint sampled_item.pre_delay {
            bins none   = {0};
            bins short  = {[1:3]};
            bins medium = {[4:7]};
            bins long_delay = {[8:$]};
        }
        
        // Post-delay coverage
        cp_post_delay: coverpoint sampled_item.post_delay {
            bins none   = {0};
            bins short  = {[1:3]};
            bins medium = {[4:7]};
            bins long_delay = {[8:$]};
        }
        
        // Inter-byte gap
        cp_inter_byte: coverpoint sampled_item.inter_byte_gap {
            bins none  = {0};
            bins small = {[1:2]};
            bins large = {[3:$]};
        }
        
        // Timing combinations
        delays_cross: cross cp_pre_delay, cp_post_delay;
    endgroup
    
    // Multi-byte transfer coverage
    covergroup spi_multibyte_cg;
        option.per_instance = 1;
        option.name = "spi_multibyte_coverage";
        
        cp_num_bytes: coverpoint sampled_item.num_bytes {
            bins single    = {1};
            bins small     = {[2:4]};
            bins medium    = {[5:8]};
            bins large     = {[9:16]};
            bins very_large = {[17:$]};
        }
    endgroup
    
    // Error and edge case coverage
    covergroup spi_corner_cg;
        option.per_instance = 1;
        option.name = "spi_corner_coverage";
        
        cp_transfer_error: coverpoint sampled_item.transfer_error {
            bins no_error = {0};
            bins error    = {1};
        }
        
        cp_complete: coverpoint sampled_item.transfer_complete {
            bins incomplete = {0};
            bins complete   = {1};
        }
    endgroup
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "spi_coverage", uvm_component parent = null);
        super.new(name, parent);
        spi_transaction_cg = new();
        spi_data_cg = new();
        spi_timing_cg = new();
        spi_multibyte_cg = new();
        spi_corner_cg = new();
    endfunction
    
    //--------------------------------------------------------------------------
    // Write Method (from analysis port)
    //--------------------------------------------------------------------------
    
    virtual function void write(spi_seq_item t);
        sampled_item = t;
        
        // Sample all coverage groups
        spi_transaction_cg.sample();
        spi_data_cg.sample();
        spi_timing_cg.sample();
        spi_multibyte_cg.sample();
        spi_corner_cg.sample();
        
        `uvm_info("SPI_COV", $sformatf("Sampled coverage for transaction"), UVM_HIGH)
    endfunction
    
    //--------------------------------------------------------------------------
    // Report Phase
    //--------------------------------------------------------------------------
    
    virtual function void report_phase(uvm_phase phase);
        real total_cov;
        string report;
        
        total_cov = (spi_transaction_cg.get_coverage() + 
                     spi_data_cg.get_coverage() + 
                     spi_timing_cg.get_coverage() +
                     spi_multibyte_cg.get_coverage() +
                     spi_corner_cg.get_coverage()) / 5.0;
        
        report = "\n";
        report = {report, "╔══════════════════════════════════════════════════════════════╗\n"};
        report = {report, "║                  SPI Coverage Report                         ║\n"};
        report = {report, "╠══════════════════════════════════════════════════════════════╣\n"};
        report = {report, $sformatf("║  Transaction Coverage  : %6.2f%%                            ║\n", spi_transaction_cg.get_coverage())};
        report = {report, $sformatf("║  Data Coverage         : %6.2f%%                            ║\n", spi_data_cg.get_coverage())};
        report = {report, $sformatf("║  Timing Coverage       : %6.2f%%                            ║\n", spi_timing_cg.get_coverage())};
        report = {report, $sformatf("║  Multi-byte Coverage   : %6.2f%%                            ║\n", spi_multibyte_cg.get_coverage())};
        report = {report, $sformatf("║  Corner Case Coverage  : %6.2f%%                            ║\n", spi_corner_cg.get_coverage())};
        report = {report, "╠══════════════════════════════════════════════════════════════╣\n"};
        report = {report, $sformatf("║  TOTAL COVERAGE        : %6.2f%%                            ║\n", total_cov)};
        report = {report, "╚══════════════════════════════════════════════════════════════╝\n"};
        
        `uvm_info("SPI_COV", report, UVM_LOW)
        
        if (total_cov < 80.0) begin
            `uvm_warning("SPI_COV", $sformatf("Coverage goal not met: %.2f%% < 80%%", total_cov))
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Get Coverage Methods
    //--------------------------------------------------------------------------
    
    function real get_total_coverage();
        return (spi_transaction_cg.get_coverage() + 
                spi_data_cg.get_coverage() + 
                spi_timing_cg.get_coverage() +
                spi_multibyte_cg.get_coverage() +
                spi_corner_cg.get_coverage()) / 5.0;
    endfunction
    
    function real get_transaction_coverage();
        return spi_transaction_cg.get_coverage();
    endfunction
    
    function real get_data_coverage();
        return spi_data_cg.get_coverage();
    endfunction
    
endclass : spi_coverage

`endif // SPI_COVERAGE_SV
