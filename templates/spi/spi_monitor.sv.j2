//------------------------------------------------------------------------------
// SPI Monitor
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef SPI_MONITOR_SV
`define SPI_MONITOR_SV

class spi_monitor extends uvm_monitor;
    
    `uvm_component_utils(spi_monitor)
    
    //--------------------------------------------------------------------------
    // Virtual Interface
    //--------------------------------------------------------------------------
    virtual spi_if vif;
    
    //--------------------------------------------------------------------------
    // Analysis Ports
    //--------------------------------------------------------------------------
    uvm_analysis_port #(spi_seq_item) item_collected_port;
    uvm_analysis_port #(spi_seq_item) mosi_port;  // Master->Slave transactions
    uvm_analysis_port #(spi_seq_item) miso_port;  // Slave->Master transactions
    
    //--------------------------------------------------------------------------
    // Configuration
    //--------------------------------------------------------------------------
    spi_mode_t monitor_mode = SPI_MODE_{{ spi_mode | default(0) }};
    bit checks_enable = 1;
    bit coverage_enable = 1;
    
    //--------------------------------------------------------------------------
    // Coverage
    //--------------------------------------------------------------------------
    spi_seq_item collected_item;
    
    covergroup spi_transaction_cg;
        option.per_instance = 1;
        
        cp_operation: coverpoint collected_item.operation {
            bins write     = {SPI_WRITE};
            bins read      = {SPI_READ};
            bins write_read = {SPI_WRITE_READ};
        }
        
        cp_mode: coverpoint collected_item.mode {
            bins mode0 = {SPI_MODE_0};
            bins mode1 = {SPI_MODE_1};
            bins mode2 = {SPI_MODE_2};
            bins mode3 = {SPI_MODE_3};
        }
        
        cp_slave: coverpoint collected_item.slave_select {
            bins slaves[] = {[0:SPI_NUM_SLAVES-1]};
        }
        
        cp_data_patterns: coverpoint collected_item.mosi_data {
            bins zero      = {0};
            bins all_ones  = { {SPI_DATA_WIDTH{1'b1}} };
            bins low       = {[1:8'h0F]};
            bins mid       = {[8'h10:8'hEF]};
            bins high      = {[8'hF0:8'hFE]};
        }
        
        cp_bit_order: coverpoint collected_item.bit_order {
            bins msb_first = {SPI_MSB_FIRST};
            bins lsb_first = {SPI_LSB_FIRST};
        }
        
        // Cross coverage
        mode_x_slave: cross cp_mode, cp_slave;
    endgroup
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "spi_monitor", uvm_component parent = null);
        super.new(name, parent);
        item_collected_port = new("item_collected_port", this);
        mosi_port = new("mosi_port", this);
        miso_port = new("miso_port", this);
        spi_transaction_cg = new();
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual spi_if)::get(this, "", "vif", vif)) begin
            `uvm_fatal("SPI_MON", "Virtual interface not found in config DB")
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    virtual task run_phase(uvm_phase phase);
        collected_item = spi_seq_item::type_id::create("collected_item");
        
        forever begin
            fork
                collect_transaction();
            join
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Transaction Collection
    //--------------------------------------------------------------------------
    
    virtual task collect_transaction();
        spi_seq_item item;
        logic [SPI_DATA_WIDTH-1:0] mosi_data;
        logic [SPI_DATA_WIDTH-1:0] miso_data;
        int slave_idx;
        
        item = spi_seq_item::type_id::create("item");
        
        // Wait for CS assertion
        wait_for_cs_assertion(slave_idx);
        
        `uvm_info("SPI_MON", $sformatf("CS[%0d] asserted - starting capture", slave_idx), UVM_HIGH)
        
        // Capture data based on mode
        capture_data(mosi_data, miso_data);
        
        // Wait for CS de-assertion
        @(posedge vif.cs_n[slave_idx]);
        
        // Populate item
        item.mosi_data = mosi_data;
        item.miso_data = miso_data;
        item.slave_select = slave_idx;
        item.mode = monitor_mode;
        item.operation = SPI_WRITE_READ;  // Assume full duplex
        item.transfer_complete = 1;
        
        // Update coverage reference and sample
        collected_item = item;
        if (coverage_enable) begin
            spi_transaction_cg.sample();
        end
        
        // Protocol checks
        if (checks_enable) begin
            perform_checks(item);
        end
        
        // Send to analysis ports
        item_collected_port.write(item);
        mosi_port.write(item);
        miso_port.write(item);
        
        `uvm_info("SPI_MON", $sformatf("Collected transaction:\n%s", item.convert2string()), UVM_MEDIUM)
    endtask
    
    //--------------------------------------------------------------------------
    // Wait for CS Assertion
    //--------------------------------------------------------------------------
    
    virtual task wait_for_cs_assertion(output int slave_idx);
        slave_idx = -1;
        
        @(posedge vif.clk);
        
        // Wait for any CS to go low
        while (vif.cs_n == '1) begin
            @(posedge vif.clk);
        end
        
        // Determine which slave is selected
        for (int i = 0; i < SPI_NUM_SLAVES; i++) begin
            if (vif.cs_n[i] == 0) begin
                slave_idx = i;
                break;
            end
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Data Capture
    //--------------------------------------------------------------------------
    
    virtual task capture_data(output logic [SPI_DATA_WIDTH-1:0] mosi_data,
                              output logic [SPI_DATA_WIDTH-1:0] miso_data);
        int bit_count = 0;
        mosi_data = '0;
        miso_data = '0;
        
        // Capture based on SPI mode
        case (monitor_mode)
            SPI_MODE_0: capture_mode0(mosi_data, miso_data);
            SPI_MODE_1: capture_mode1(mosi_data, miso_data);
            SPI_MODE_2: capture_mode2(mosi_data, miso_data);
            SPI_MODE_3: capture_mode3(mosi_data, miso_data);
        endcase
    endtask
    
    // Mode 0: CPOL=0, CPHA=0 - Sample on rising edge
    virtual task capture_mode0(output logic [SPI_DATA_WIDTH-1:0] mosi_data,
                               output logic [SPI_DATA_WIDTH-1:0] miso_data);
        mosi_data = '0;
        miso_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            @(posedge vif.sclk);
            if (vif.cs_n == '1) break;  // CS released early
            mosi_data[i] = vif.mosi;
            miso_data[i] = vif.miso;
        end
    endtask
    
    // Mode 1: CPOL=0, CPHA=1 - Sample on falling edge
    virtual task capture_mode1(output logic [SPI_DATA_WIDTH-1:0] mosi_data,
                               output logic [SPI_DATA_WIDTH-1:0] miso_data);
        mosi_data = '0;
        miso_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            @(negedge vif.sclk);
            if (vif.cs_n == '1) break;
            mosi_data[i] = vif.mosi;
            miso_data[i] = vif.miso;
        end
    endtask
    
    // Mode 2: CPOL=1, CPHA=0 - Sample on falling edge
    virtual task capture_mode2(output logic [SPI_DATA_WIDTH-1:0] mosi_data,
                               output logic [SPI_DATA_WIDTH-1:0] miso_data);
        mosi_data = '0;
        miso_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            @(negedge vif.sclk);
            if (vif.cs_n == '1) break;
            mosi_data[i] = vif.mosi;
            miso_data[i] = vif.miso;
        end
    endtask
    
    // Mode 3: CPOL=1, CPHA=1 - Sample on rising edge
    virtual task capture_mode3(output logic [SPI_DATA_WIDTH-1:0] mosi_data,
                               output logic [SPI_DATA_WIDTH-1:0] miso_data);
        mosi_data = '0;
        miso_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            @(posedge vif.sclk);
            if (vif.cs_n == '1) break;
            mosi_data[i] = vif.mosi;
            miso_data[i] = vif.miso;
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Protocol Checks
    //--------------------------------------------------------------------------
    
    virtual function void perform_checks(spi_seq_item item);
        // Check for X/Z on data
        if ($isunknown(item.mosi_data)) begin
            `uvm_error("SPI_MON", "MOSI data contains X or Z")
        end
        
        if ($isunknown(item.miso_data)) begin
            `uvm_warning("SPI_MON", "MISO data contains X or Z - slave may not be responding")
        end
        
        // Check slave select is valid
        if (item.slave_select >= SPI_NUM_SLAVES) begin
            `uvm_error("SPI_MON", $sformatf("Invalid slave select: %0d", item.slave_select))
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Report Phase
    //--------------------------------------------------------------------------
    
    virtual function void report_phase(uvm_phase phase);
        `uvm_info("SPI_MON", $sformatf("Coverage: %.2f%%", spi_transaction_cg.get_coverage()), UVM_LOW)
    endfunction
    
endclass : spi_monitor

`endif // SPI_MONITOR_SV
