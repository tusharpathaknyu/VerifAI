//------------------------------------------------------------------------------
// SPI Driver
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef SPI_DRIVER_SV
`define SPI_DRIVER_SV

class spi_driver extends uvm_driver #(spi_seq_item);
    
    `uvm_component_utils(spi_driver)
    
    //--------------------------------------------------------------------------
    // Virtual Interface
    //--------------------------------------------------------------------------
    virtual spi_if vif;
    
    //--------------------------------------------------------------------------
    // Configuration
    //--------------------------------------------------------------------------
    int unsigned sclk_half_period = {{ spi_clock_divider | default(2) }};  // Clock divider
    bit is_master = 1;  // Master mode by default
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "spi_driver", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual spi_if)::get(this, "", "vif", vif)) begin
            `uvm_fatal("SPI_DRV", "Virtual interface not found in config DB")
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    virtual task run_phase(uvm_phase phase);
        spi_seq_item req;
        
        // Initialize interface
        init_interface();
        
        forever begin
            seq_item_port.get_next_item(req);
            `uvm_info("SPI_DRV", $sformatf("Driving transaction:\n%s", req.convert2string()), UVM_MEDIUM)
            
            if (is_master)
                drive_master_transfer(req);
            else
                drive_slave_transfer(req);
            
            req.transfer_complete = 1;
            seq_item_port.item_done();
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Interface Initialization
    //--------------------------------------------------------------------------
    
    virtual task init_interface();
        @(posedge vif.clk);
        // Set SCLK idle state based on CPOL
        vif.sclk <= get_sclk_idle();
        vif.cs_n <= '1;  // All CS inactive
        vif.mosi <= 1'b0;
    endtask
    
    //--------------------------------------------------------------------------
    // Master Transfer
    //--------------------------------------------------------------------------
    
    virtual task drive_master_transfer(spi_seq_item item);
        logic [SPI_DATA_WIDTH-1:0] tx_data;
        logic [SPI_DATA_WIDTH-1:0] rx_data;
        
        // Get transmit data with proper bit ordering
        tx_data = item.get_tx_data();
        rx_data = '0;
        
        // Pre-delay
        repeat(item.pre_delay) @(posedge vif.clk);
        
        // Assert chip select
        vif.cs_n[item.slave_select] <= 1'b0;
        
        // CS setup time
        repeat({{ spi_cs_setup_time | default(1) }}) @(posedge vif.clk);
        
        // Transfer data based on SPI mode
        case (item.mode)
            SPI_MODE_0: drive_mode0(tx_data, rx_data);
            SPI_MODE_1: drive_mode1(tx_data, rx_data);
            SPI_MODE_2: drive_mode2(tx_data, rx_data);
            SPI_MODE_3: drive_mode3(tx_data, rx_data);
        endcase
        
        // CS hold time
        repeat({{ spi_cs_hold_time | default(1) }}) @(posedge vif.clk);
        
        // De-assert chip select
        vif.cs_n[item.slave_select] <= 1'b1;
        
        // Post-delay
        repeat(item.post_delay) @(posedge vif.clk);
        
        // Store received data
        item.set_rx_data(rx_data);
        
        `uvm_info("SPI_DRV", $sformatf("Transfer complete: TX=0x%0h, RX=0x%0h", tx_data, rx_data), UVM_HIGH)
    endtask
    
    //--------------------------------------------------------------------------
    // SPI Mode 0: CPOL=0, CPHA=0
    // Data sampled on rising edge, shifted on falling edge
    //--------------------------------------------------------------------------
    
    virtual task drive_mode0(input logic [SPI_DATA_WIDTH-1:0] tx_data,
                             output logic [SPI_DATA_WIDTH-1:0] rx_data);
        rx_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            // Setup data on MOSI before rising edge
            vif.mosi <= tx_data[i];
            
            // Rising edge - sample MISO
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b1;
            rx_data[i] = vif.miso;
            
            // Falling edge
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b0;
        end
    endtask
    
    //--------------------------------------------------------------------------
    // SPI Mode 1: CPOL=0, CPHA=1
    // Data sampled on falling edge, shifted on rising edge
    //--------------------------------------------------------------------------
    
    virtual task drive_mode1(input logic [SPI_DATA_WIDTH-1:0] tx_data,
                             output logic [SPI_DATA_WIDTH-1:0] rx_data);
        rx_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            // Rising edge - shift out data
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b1;
            vif.mosi <= tx_data[i];
            
            // Falling edge - sample MISO
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b0;
            rx_data[i] = vif.miso;
        end
    endtask
    
    //--------------------------------------------------------------------------
    // SPI Mode 2: CPOL=1, CPHA=0
    // Data sampled on falling edge, shifted on rising edge
    //--------------------------------------------------------------------------
    
    virtual task drive_mode2(input logic [SPI_DATA_WIDTH-1:0] tx_data,
                             output logic [SPI_DATA_WIDTH-1:0] rx_data);
        rx_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            // Setup data on MOSI before falling edge
            vif.mosi <= tx_data[i];
            
            // Falling edge - sample MISO
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b0;
            rx_data[i] = vif.miso;
            
            // Rising edge
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b1;
        end
    endtask
    
    //--------------------------------------------------------------------------
    // SPI Mode 3: CPOL=1, CPHA=1
    // Data sampled on rising edge, shifted on falling edge
    //--------------------------------------------------------------------------
    
    virtual task drive_mode3(input logic [SPI_DATA_WIDTH-1:0] tx_data,
                             output logic [SPI_DATA_WIDTH-1:0] rx_data);
        rx_data = '0;
        
        for (int i = SPI_DATA_WIDTH-1; i >= 0; i--) begin
            // Falling edge - shift out data
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b0;
            vif.mosi <= tx_data[i];
            
            // Rising edge - sample MISO
            repeat(sclk_half_period) @(posedge vif.clk);
            vif.sclk <= 1'b1;
            rx_data[i] = vif.miso;
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Slave Transfer (for slave agent)
    //--------------------------------------------------------------------------
    
    virtual task drive_slave_transfer(spi_seq_item item);
        logic [SPI_DATA_WIDTH-1:0] tx_data;
        int bit_idx;
        
        tx_data = item.get_tx_data();
        
        // Wait for CS assertion
        @(negedge vif.cs_n[0]);
        
        bit_idx = SPI_DATA_WIDTH - 1;
        
        // Drive MISO based on mode
        while (vif.cs_n[0] == 0 && bit_idx >= 0) begin
            case (item.mode)
                SPI_MODE_0, SPI_MODE_3: begin
                    // Sample on rising, so drive before
                    vif.miso <= tx_data[bit_idx];
                    @(posedge vif.sclk);
                    bit_idx--;
                end
                SPI_MODE_1, SPI_MODE_2: begin
                    // Sample on falling, so drive before
                    vif.miso <= tx_data[bit_idx];
                    @(negedge vif.sclk);
                    bit_idx--;
                end
            endcase
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Helper Functions
    //--------------------------------------------------------------------------
    
    function bit get_sclk_idle();
        // CPOL determines idle state
        return (SPI_MODE >= 2) ? 1'b1 : 1'b0;
    endfunction
    
endclass : spi_driver

`endif // SPI_DRIVER_SV
