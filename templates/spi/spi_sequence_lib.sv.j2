//------------------------------------------------------------------------------
// SPI Sequence Library
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef SPI_SEQUENCE_LIB_SV
`define SPI_SEQUENCE_LIB_SV

//==============================================================================
// Base SPI Sequence
//==============================================================================

class spi_base_sequence extends uvm_sequence #(spi_seq_item);
    
    `uvm_object_utils(spi_base_sequence)
    
    // Default configuration
    spi_mode_t seq_mode = SPI_MODE_{{ spi_mode | default(0) }};
    int unsigned target_slave = 0;
    
    function new(string name = "spi_base_sequence");
        super.new(name);
    endfunction
    
    virtual task pre_body();
        if (starting_phase != null)
            starting_phase.raise_objection(this, {"Running: ", get_full_name()});
    endtask
    
    virtual task post_body();
        if (starting_phase != null)
            starting_phase.drop_objection(this, {"Completed: ", get_full_name()});
    endtask
    
endclass : spi_base_sequence

//==============================================================================
// Single Write Sequence
//==============================================================================

class spi_single_write_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_single_write_seq)
    
    rand logic [SPI_DATA_WIDTH-1:0] write_data;
    
    function new(string name = "spi_single_write_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        item = spi_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            operation == SPI_WRITE;
            mosi_data == local::write_data;
            mode == local::seq_mode;
            slave_select == local::target_slave;
        }) begin
            `uvm_error("SPI_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        `uvm_info("SPI_SEQ", $sformatf("Write: 0x%0h to slave %0d", write_data, target_slave), UVM_MEDIUM)
    endtask
    
endclass : spi_single_write_seq

//==============================================================================
// Single Read Sequence
//==============================================================================

class spi_single_read_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_single_read_seq)
    
    logic [SPI_DATA_WIDTH-1:0] read_data;
    
    function new(string name = "spi_single_read_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        item = spi_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            operation == SPI_READ;
            mode == local::seq_mode;
            slave_select == local::target_slave;
        }) begin
            `uvm_error("SPI_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        read_data = item.miso_data;
        
        `uvm_info("SPI_SEQ", $sformatf("Read: 0x%0h from slave %0d", read_data, target_slave), UVM_MEDIUM)
    endtask
    
endclass : spi_single_read_seq

//==============================================================================
// Write-Read (Full Duplex) Sequence
//==============================================================================

class spi_write_read_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_write_read_seq)
    
    rand logic [SPI_DATA_WIDTH-1:0] write_data;
    logic [SPI_DATA_WIDTH-1:0] read_data;
    
    function new(string name = "spi_write_read_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        item = spi_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            operation == SPI_WRITE_READ;
            mosi_data == local::write_data;
            mode == local::seq_mode;
            slave_select == local::target_slave;
        }) begin
            `uvm_error("SPI_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        read_data = item.miso_data;
        
        `uvm_info("SPI_SEQ", $sformatf("Write/Read: TX=0x%0h, RX=0x%0h, slave=%0d", 
                  write_data, read_data, target_slave), UVM_MEDIUM)
    endtask
    
endclass : spi_write_read_seq

//==============================================================================
// Multi-Byte Transfer Sequence
//==============================================================================

class spi_multi_byte_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_multi_byte_seq)
    
    rand int unsigned num_bytes;
    rand logic [7:0] tx_data[];
    logic [7:0] rx_data[];
    
    constraint c_num_bytes {
        num_bytes inside {[1:16]};
        tx_data.size() == num_bytes;
    }
    
    function new(string name = "spi_multi_byte_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        rx_data = new[num_bytes];
        
        for (int i = 0; i < num_bytes; i++) begin
            item = spi_seq_item::type_id::create($sformatf("item_%0d", i));
            
            start_item(item);
            if (!item.randomize() with {
                operation == SPI_WRITE_READ;
                mosi_data == local::tx_data[i];
                mode == local::seq_mode;
                slave_select == local::target_slave;
                // First byte has pre-delay, last byte has post-delay
                pre_delay == (i == 0) ? 2 : 0;
                post_delay == (i == local::num_bytes-1) ? 2 : 0;
            }) begin
                `uvm_error("SPI_SEQ", "Randomization failed")
            end
            finish_item(item);
            
            rx_data[i] = item.miso_data[7:0];
        end
        
        `uvm_info("SPI_SEQ", $sformatf("Multi-byte transfer: %0d bytes", num_bytes), UVM_MEDIUM)
    endtask
    
endclass : spi_multi_byte_seq

//==============================================================================
// Random Traffic Sequence
//==============================================================================

class spi_random_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_random_seq)
    
    rand int unsigned num_transactions;
    
    constraint c_num_trans {
        num_transactions inside {[5:20]};
    }
    
    function new(string name = "spi_random_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        `uvm_info("SPI_SEQ", $sformatf("Starting random sequence with %0d transactions", num_transactions), UVM_MEDIUM)
        
        for (int i = 0; i < num_transactions; i++) begin
            item = spi_seq_item::type_id::create($sformatf("item_%0d", i));
            
            start_item(item);
            if (!item.randomize() with {
                mode == local::seq_mode;
            }) begin
                `uvm_error("SPI_SEQ", "Randomization failed")
            end
            finish_item(item);
        end
        
        `uvm_info("SPI_SEQ", "Random sequence completed", UVM_MEDIUM)
    endtask
    
endclass : spi_random_seq

//==============================================================================
// Mode Sweep Sequence (Tests all 4 SPI modes)
//==============================================================================

class spi_mode_sweep_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_mode_sweep_seq)
    
    function new(string name = "spi_mode_sweep_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        spi_mode_t modes[] = '{SPI_MODE_0, SPI_MODE_1, SPI_MODE_2, SPI_MODE_3};
        
        `uvm_info("SPI_SEQ", "Starting mode sweep sequence", UVM_MEDIUM)
        
        foreach (modes[i]) begin
            item = spi_seq_item::type_id::create($sformatf("item_mode%0d", i));
            
            start_item(item);
            if (!item.randomize() with {
                mode == modes[i];
                slave_select == local::target_slave;
            }) begin
                `uvm_error("SPI_SEQ", "Randomization failed")
            end
            finish_item(item);
            
            `uvm_info("SPI_SEQ", $sformatf("Completed transfer in %s", modes[i].name()), UVM_MEDIUM)
        end
    endtask
    
endclass : spi_mode_sweep_seq

//==============================================================================
// All Slaves Sequence
//==============================================================================

class spi_all_slaves_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_all_slaves_seq)
    
    function new(string name = "spi_all_slaves_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        `uvm_info("SPI_SEQ", "Starting all-slaves sequence", UVM_MEDIUM)
        
        for (int slave = 0; slave < SPI_NUM_SLAVES; slave++) begin
            item = spi_seq_item::type_id::create($sformatf("item_slave%0d", slave));
            
            start_item(item);
            if (!item.randomize() with {
                slave_select == slave;
                mode == local::seq_mode;
            }) begin
                `uvm_error("SPI_SEQ", "Randomization failed")
            end
            finish_item(item);
            
            `uvm_info("SPI_SEQ", $sformatf("Completed transfer to slave %0d", slave), UVM_MEDIUM)
        end
    endtask
    
endclass : spi_all_slaves_seq

//==============================================================================
// Walking Ones/Zeros Sequence (for data integrity testing)
//==============================================================================

class spi_walking_pattern_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_walking_pattern_seq)
    
    typedef enum {WALKING_ONES, WALKING_ZEROS} pattern_t;
    rand pattern_t pattern;
    
    function new(string name = "spi_walking_pattern_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        logic [SPI_DATA_WIDTH-1:0] data;
        
        `uvm_info("SPI_SEQ", $sformatf("Starting %s pattern", pattern.name()), UVM_MEDIUM)
        
        for (int i = 0; i < SPI_DATA_WIDTH; i++) begin
            if (pattern == WALKING_ONES)
                data = (1 << i);
            else
                data = ~(1 << i);
            
            item = spi_seq_item::type_id::create($sformatf("item_%0d", i));
            
            start_item(item);
            if (!item.randomize() with {
                mosi_data == local::data;
                mode == local::seq_mode;
                slave_select == local::target_slave;
            }) begin
                `uvm_error("SPI_SEQ", "Randomization failed")
            end
            finish_item(item);
        end
    endtask
    
endclass : spi_walking_pattern_seq

//==============================================================================
// Burst Transfer Sequence
//==============================================================================

class spi_burst_seq extends spi_base_sequence;
    
    `uvm_object_utils(spi_burst_seq)
    
    rand int unsigned burst_length;
    rand int unsigned inter_burst_delay;
    
    constraint c_burst {
        burst_length inside {[4:16]};
        inter_burst_delay inside {[0:5]};
    }
    
    function new(string name = "spi_burst_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        spi_seq_item item;
        
        `uvm_info("SPI_SEQ", $sformatf("Starting burst of %0d transfers", burst_length), UVM_MEDIUM)
        
        for (int i = 0; i < burst_length; i++) begin
            item = spi_seq_item::type_id::create($sformatf("burst_%0d", i));
            
            start_item(item);
            if (!item.randomize() with {
                mode == local::seq_mode;
                slave_select == local::target_slave;
                // Minimal gap within burst
                pre_delay == 0;
                post_delay == (i == local::burst_length-1) ? local::inter_burst_delay : 0;
            }) begin
                `uvm_error("SPI_SEQ", "Randomization failed")
            end
            finish_item(item);
        end
    endtask
    
endclass : spi_burst_seq

`endif // SPI_SEQUENCE_LIB_SV
