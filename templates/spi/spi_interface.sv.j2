//------------------------------------------------------------------------------
// SPI Interface
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef SPI_INTERFACE_SV
`define SPI_INTERFACE_SV

interface spi_if #(
    parameter int DATA_WIDTH = {{ data_width | default(8) }},
    parameter int NUM_SLAVES = {{ spi_num_slaves | default(1) }}
)(
    input logic clk,
    input logic rst_n
);
    
    //--------------------------------------------------------------------------
    // SPI Signals
    //--------------------------------------------------------------------------
    logic                    sclk;        // SPI clock
    logic [NUM_SLAVES-1:0]   cs_n;        // Chip select (active low)
    logic                    mosi;        // Master Out Slave In
    logic                    miso;        // Master In Slave Out
    
    // Quad SPI signals (optional)
    logic [3:0]              io;          // Quad I/O for QSPI
    logic                    io_oe;       // I/O output enable
    
    // Interrupt (optional)
    logic                    irq_n;       // Interrupt request (active low)
    
    //--------------------------------------------------------------------------
    // Internal Signals for Monitoring
    //--------------------------------------------------------------------------
    logic [DATA_WIDTH-1:0]   mosi_data;   // Captured MOSI data
    logic [DATA_WIDTH-1:0]   miso_data;   // Captured MISO data
    logic                    transfer_active;
    int                      bit_count;
    
    //--------------------------------------------------------------------------
    // Clocking Blocks
    //--------------------------------------------------------------------------
    
    // Master clocking block (Mode 0/2 - sample on rising edge)
    clocking master_cb @(posedge sclk);
        default input #1step output #1ns;
        output mosi;
        input  miso;
        output cs_n;
    endclocking
    
    // Slave clocking block
    clocking slave_cb @(posedge sclk);
        default input #1step output #1ns;
        input  mosi;
        output miso;
        input  cs_n;
    endclocking
    
    // Monitor clocking block (system clock domain)
    clocking mon_cb @(posedge clk);
        default input #1step;
        input sclk;
        input cs_n;
        input mosi;
        input miso;
        input io;
    endclocking
    
    //--------------------------------------------------------------------------
    // Modports
    //--------------------------------------------------------------------------
    modport master_mp (
        input  clk, rst_n, miso, irq_n,
        output sclk, cs_n, mosi,
        inout  io
    );
    
    modport slave_mp (
        input  clk, rst_n, sclk, cs_n, mosi,
        output miso, irq_n,
        inout  io
    );
    
    modport monitor_mp (
        input clk, rst_n, sclk, cs_n, mosi, miso, io, irq_n
    );
    
    //--------------------------------------------------------------------------
    // Assertions
    //--------------------------------------------------------------------------
    
    // CS must be stable during transfer
    property cs_stable_during_sclk;
        @(posedge clk) disable iff (!rst_n)
        $fell(cs_n[0]) |-> ##1 (cs_n[0] == 0) throughout ($rose(cs_n[0])[->1]);
    endproperty
    assert_cs_stable: assert property (cs_stable_during_sclk)
        else `uvm_error("SPI_IF", "CS changed during active transfer")
    
    // SCLK should only toggle when CS is low
    property sclk_only_when_cs_low;
        @(posedge clk) disable iff (!rst_n)
        (cs_n[0] == 1) |-> $stable(sclk);
    endproperty
    assert_sclk_gated: assert property (sclk_only_when_cs_low)
        else `uvm_warning("SPI_IF", "SCLK toggling while CS is high")
    
    // No X on data lines during transfer
    property no_x_on_mosi;
        @(posedge sclk) disable iff (!rst_n)
        (cs_n[0] == 0) |-> !$isunknown(mosi);
    endproperty
    assert_mosi_valid: assert property (no_x_on_mosi)
        else `uvm_error("SPI_IF", "MOSI has X during transfer")
    
    property no_x_on_miso;
        @(posedge sclk) disable iff (!rst_n)
        (cs_n[0] == 0) |-> !$isunknown(miso);
    endproperty
    assert_miso_valid: assert property (no_x_on_miso)
        else `uvm_error("SPI_IF", "MISO has X during transfer")
    
    //--------------------------------------------------------------------------
    // Coverage
    //--------------------------------------------------------------------------
    covergroup spi_if_cg @(posedge sclk);
        option.per_instance = 1;
        
        cp_cs: coverpoint cs_n[0] {
            bins active   = {0};
            bins inactive = {1};
        }
        
        cp_mosi: coverpoint mosi {
            bins zero = {0};
            bins one  = {1};
        }
        
        cp_miso: coverpoint miso {
            bins zero = {0};
            bins one  = {1};
        }
    endgroup
    
    spi_if_cg spi_cov = new();
    
    //--------------------------------------------------------------------------
    // Tasks
    //--------------------------------------------------------------------------
    
    // Initialize interface
    task automatic init();
        sclk <= {% if spi_mode is defined and spi_mode >= 2 %}1'b1{% else %}1'b0{% endif %};  // Idle state based on CPOL
        cs_n <= '1;  // All CS inactive
        mosi <= 1'b0;
        io   <= 4'b0000;
        io_oe <= 1'b0;
        transfer_active <= 1'b0;
        bit_count <= 0;
    endtask
    
    // Wait for transfer to complete
    task automatic wait_transfer_done();
        @(posedge clk);
        wait(cs_n[0] == 1);
        @(posedge clk);
    endtask
    
    // Monitor transfer
    task automatic capture_transfer(output logic [DATA_WIDTH-1:0] tx_data, 
                                    output logic [DATA_WIDTH-1:0] rx_data);
        tx_data = '0;
        rx_data = '0;
        wait(cs_n[0] == 0);
        for (int i = DATA_WIDTH-1; i >= 0; i--) begin
            @(posedge sclk);
            tx_data[i] = mosi;
            rx_data[i] = miso;
        end
    endtask
    
endinterface : spi_if

`endif // SPI_INTERFACE_SV
