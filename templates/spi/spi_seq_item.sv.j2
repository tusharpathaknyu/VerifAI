//------------------------------------------------------------------------------
// SPI Sequence Item
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef SPI_SEQ_ITEM_SV
`define SPI_SEQ_ITEM_SV

class spi_seq_item extends uvm_sequence_item;
    
    //--------------------------------------------------------------------------
    // Transaction Fields
    //--------------------------------------------------------------------------
    
    // Data fields
    rand logic [SPI_DATA_WIDTH-1:0] mosi_data;    // Data to send
    logic [SPI_DATA_WIDTH-1:0]      miso_data;    // Data received
    
    // Control fields
    rand spi_op_t         operation;      // Read/Write/Full-duplex
    rand spi_mode_t       mode;           // SPI mode (0-3)
    rand spi_width_t      width;          // Single/Dual/Quad
    rand spi_bit_order_t  bit_order;      // MSB/LSB first
    rand int unsigned     slave_select;   // Which slave to select
    
    // Timing fields
    rand int unsigned     pre_delay;      // Delay before CS assertion
    rand int unsigned     post_delay;     // Delay after CS de-assertion
    rand int unsigned     inter_byte_gap; // Gap between bytes (multi-byte transfer)
    
    // Multi-byte transfer
    rand int unsigned     num_bytes;      // Number of bytes to transfer
    rand logic [7:0]      data_queue[$];  // Queue for multi-byte transfers
    logic [7:0]           rx_queue[$];    // Received data queue
    
    // Status
    bit transfer_complete;
    bit transfer_error;
    
    //--------------------------------------------------------------------------
    // Constraints
    //--------------------------------------------------------------------------
    
    constraint c_slave_select {
        slave_select < SPI_NUM_SLAVES;
    }
    
    constraint c_delays {
        pre_delay inside {[0:10]};
        post_delay inside {[0:10]};
        inter_byte_gap inside {[0:5]};
    }
    
    constraint c_num_bytes {
        num_bytes inside {[1:16]};
        data_queue.size() == num_bytes;
    }
    
    constraint c_valid_mode {
        mode inside {SPI_MODE_0, SPI_MODE_1, SPI_MODE_2, SPI_MODE_3};
    }
    
    constraint c_default_mode {
        soft mode == SPI_MODE_{{ spi_mode | default(0) }};
    }
    
    constraint c_default_width {
        soft width == SPI_SINGLE;
    }
    
    constraint c_default_bit_order {
        soft bit_order == {% if spi_msb_first | default(true) %}SPI_MSB_FIRST{% else %}SPI_LSB_FIRST{% endif %};
    }
    
    //--------------------------------------------------------------------------
    // UVM Automation
    //--------------------------------------------------------------------------
    
    `uvm_object_utils_begin(spi_seq_item)
        `uvm_field_int(mosi_data, UVM_ALL_ON)
        `uvm_field_int(miso_data, UVM_ALL_ON)
        `uvm_field_enum(spi_op_t, operation, UVM_ALL_ON)
        `uvm_field_enum(spi_mode_t, mode, UVM_ALL_ON)
        `uvm_field_enum(spi_width_t, width, UVM_ALL_ON)
        `uvm_field_enum(spi_bit_order_t, bit_order, UVM_ALL_ON)
        `uvm_field_int(slave_select, UVM_ALL_ON)
        `uvm_field_int(pre_delay, UVM_ALL_ON)
        `uvm_field_int(post_delay, UVM_ALL_ON)
        `uvm_field_int(inter_byte_gap, UVM_ALL_ON)
        `uvm_field_int(num_bytes, UVM_ALL_ON)
        `uvm_field_queue_int(data_queue, UVM_ALL_ON)
        `uvm_field_queue_int(rx_queue, UVM_ALL_ON)
        `uvm_field_int(transfer_complete, UVM_ALL_ON)
        `uvm_field_int(transfer_error, UVM_ALL_ON)
    `uvm_object_utils_end
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "spi_seq_item");
        super.new(name);
        transfer_complete = 0;
        transfer_error = 0;
    endfunction
    
    //--------------------------------------------------------------------------
    // Methods
    //--------------------------------------------------------------------------
    
    // Convert to string for debug
    virtual function string convert2string();
        string s;
        s = $sformatf("\n========== SPI Transaction ==========\n");
        s = {s, $sformatf("  Operation     : %s\n", operation.name())};
        s = {s, $sformatf("  Mode          : %s\n", mode.name())};
        s = {s, $sformatf("  Width         : %s\n", width.name())};
        s = {s, $sformatf("  Bit Order     : %s\n", bit_order.name())};
        s = {s, $sformatf("  Slave Select  : %0d\n", slave_select)};
        s = {s, $sformatf("  MOSI Data     : 0x%0h\n", mosi_data)};
        s = {s, $sformatf("  MISO Data     : 0x%0h\n", miso_data)};
        s = {s, $sformatf("  Num Bytes     : %0d\n", num_bytes)};
        s = {s, $sformatf("  Pre Delay     : %0d\n", pre_delay)};
        s = {s, $sformatf("  Post Delay    : %0d\n", post_delay)};
        s = {s, $sformatf("  Complete      : %0b\n", transfer_complete)};
        s = {s, $sformatf("  Error         : %0b\n", transfer_error)};
        s = {s, "======================================\n"};
        return s;
    endfunction
    
    // Bit reversal for LSB-first mode
    function logic [SPI_DATA_WIDTH-1:0] reverse_bits(logic [SPI_DATA_WIDTH-1:0] data);
        logic [SPI_DATA_WIDTH-1:0] reversed;
        for (int i = 0; i < SPI_DATA_WIDTH; i++) begin
            reversed[i] = data[SPI_DATA_WIDTH-1-i];
        end
        return reversed;
    endfunction
    
    // Get data to transmit (handles bit order)
    function logic [SPI_DATA_WIDTH-1:0] get_tx_data();
        if (bit_order == SPI_LSB_FIRST)
            return reverse_bits(mosi_data);
        else
            return mosi_data;
    endfunction
    
    // Set received data (handles bit order)
    function void set_rx_data(logic [SPI_DATA_WIDTH-1:0] data);
        if (bit_order == SPI_LSB_FIRST)
            miso_data = reverse_bits(data);
        else
            miso_data = data;
    endfunction
    
    // Deep copy
    virtual function void do_copy(uvm_object rhs);
        spi_seq_item rhs_item;
        super.do_copy(rhs);
        if (!$cast(rhs_item, rhs)) begin
            `uvm_error("SPI_SEQ_ITEM", "Cast failed in do_copy")
            return;
        end
        this.mosi_data = rhs_item.mosi_data;
        this.miso_data = rhs_item.miso_data;
        this.operation = rhs_item.operation;
        this.mode = rhs_item.mode;
        this.width = rhs_item.width;
        this.bit_order = rhs_item.bit_order;
        this.slave_select = rhs_item.slave_select;
        this.pre_delay = rhs_item.pre_delay;
        this.post_delay = rhs_item.post_delay;
        this.inter_byte_gap = rhs_item.inter_byte_gap;
        this.num_bytes = rhs_item.num_bytes;
        this.data_queue = rhs_item.data_queue;
        this.rx_queue = rhs_item.rx_queue;
        this.transfer_complete = rhs_item.transfer_complete;
        this.transfer_error = rhs_item.transfer_error;
    endfunction
    
    // Compare
    virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
        spi_seq_item rhs_item;
        if (!$cast(rhs_item, rhs)) return 0;
        return (super.do_compare(rhs, comparer) &&
                this.mosi_data == rhs_item.mosi_data &&
                this.miso_data == rhs_item.miso_data &&
                this.operation == rhs_item.operation &&
                this.slave_select == rhs_item.slave_select);
    endfunction
    
endclass : spi_seq_item

`endif // SPI_SEQ_ITEM_SV
