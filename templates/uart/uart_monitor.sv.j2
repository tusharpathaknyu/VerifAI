//------------------------------------------------------------------------------
// UART Monitor
// Auto-generated by VerifAI
//------------------------------------------------------------------------------

class uart_monitor extends uvm_monitor;
    
    `uvm_component_utils(uart_monitor)
    
    //--------------------------------------------------------------------------
    // Analysis Port
    //--------------------------------------------------------------------------
    
    uvm_analysis_port #(uart_seq_item) ap;
    
    //--------------------------------------------------------------------------
    // Virtual Interface
    //--------------------------------------------------------------------------
    
    virtual uart_if vif;
    
    //--------------------------------------------------------------------------
    // Configuration
    //--------------------------------------------------------------------------
    
    int bit_period_ns = {{ bit_period_ns }};
    parity_type_e expected_parity = PARITY_{% if parity == 'none' %}NONE{% elif parity == 'even' %}EVEN{% elif parity == 'odd' %}ODD{% else %}NONE{% endif %};
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "uart_monitor", uvm_component parent = null);
        super.new(name, parent);
        ap = new("ap", this);
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        if (!uvm_config_db#(virtual uart_if)::get(this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    task run_phase(uvm_phase phase);
        fork
            monitor_tx();
            monitor_rx();
        join
    endtask
    
    //--------------------------------------------------------------------------
    // Monitor TX Line (DUT -> Outside)
    //--------------------------------------------------------------------------
    
    task monitor_tx();
        uart_seq_item item;
        
        forever begin
            // Wait for start bit (falling edge on TX)
            @(negedge vif.tx);
            
            item = uart_seq_item::type_id::create("tx_item");
            item.op = UART_TX;
            item.start_time = $time;
            
            // Sample byte
            sample_byte(vif.tx, item.data, item.error);
            
            item.end_time = $time;
            
            `uvm_info("UART_MON", $sformatf("TX Captured: %s", item.convert2string()), UVM_MEDIUM)
            ap.write(item);
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Monitor RX Line (Outside -> DUT)
    //--------------------------------------------------------------------------
    
    task monitor_rx();
        uart_seq_item item;
        
        forever begin
            // Wait for start bit (falling edge on RX)
            @(negedge vif.rx);
            
            item = uart_seq_item::type_id::create("rx_item");
            item.op = UART_RX;
            item.start_time = $time;
            
            // Sample byte
            sample_byte(vif.rx, item.data, item.error);
            
            item.end_time = $time;
            
            `uvm_info("UART_MON", $sformatf("RX Captured: %s", item.convert2string()), UVM_MEDIUM)
            ap.write(item);
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Sample a Byte from Serial Line
    //--------------------------------------------------------------------------
    
    task sample_byte(ref logic line, output logic [{{ data_bits }}-1:0] data, output uart_error_e error);
        logic parity_bit;
        logic calculated_parity;
        logic stop_bit;
        int half_bit = bit_period_ns / 2;
        
        error = ERR_NONE;
        data = '0;
        
        // Move to middle of start bit
        #(half_bit * 1ns);
        
        // Verify start bit is low
        if (line != 1'b0) begin
            `uvm_warning("UART_MON", "Invalid start bit detected")
            error = ERR_FRAME;
            return;
        end
        
        // Sample data bits (LSB first)
        for (int i = 0; i < {{ data_bits }}; i++) begin
            #(bit_period_ns * 1ns);
            data[i] = line;
        end
        
{% if parity != 'none' %}
        // Sample parity bit
        #(bit_period_ns * 1ns);
        parity_bit = line;
        
        // Calculate expected parity
        case (expected_parity)
            PARITY_EVEN:  calculated_parity = ^data;
            PARITY_ODD:   calculated_parity = ~(^data);
            PARITY_MARK:  calculated_parity = 1'b1;
            PARITY_SPACE: calculated_parity = 1'b0;
            default:      calculated_parity = parity_bit;
        endcase
        
        if (parity_bit != calculated_parity) begin
            `uvm_warning("UART_MON", $sformatf("Parity error: expected=%b, got=%b", calculated_parity, parity_bit))
            error = ERR_PARITY;
        end
{% endif %}
        
        // Sample stop bit
        #(bit_period_ns * 1ns);
        stop_bit = line;
        
        if (stop_bit != 1'b1) begin
            `uvm_warning("UART_MON", "Invalid stop bit (framing error)")
            error = ERR_FRAME;
        end
        
{% if stop_bits == 2 %}
        // Sample second stop bit
        #(bit_period_ns * 1ns);
        if (line != 1'b1) begin
            error = ERR_FRAME;
        end
{% endif %}
        
        `uvm_info("UART_MON", $sformatf("Sampled data: 0x%02h", data), UVM_HIGH)
    endtask
    
endclass : uart_monitor
