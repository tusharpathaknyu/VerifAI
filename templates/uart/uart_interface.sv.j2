//------------------------------------------------------------------------------
// UART Interface
// Auto-generated by VerifAI
//------------------------------------------------------------------------------

interface uart_if(input logic clk, input logic rst_n);
    
    // Serial lines
    logic tx;           // Transmit data line
    logic rx;           // Receive data line
    
{% if has_rts_cts %}
    // Hardware flow control (RTS/CTS)
    logic rts;          // Request to Send
    logic cts;          // Clear to Send
{% endif %}
    
{% if has_dtr_dsr %}
    // Modem control (DTR/DSR)
    logic dtr;          // Data Terminal Ready
    logic dsr;          // Data Set Ready
    logic dcd;          // Data Carrier Detect
    logic ri;           // Ring Indicator
{% endif %}
    
    // Timing parameters
    localparam int BIT_PERIOD_NS = {{ bit_period_ns }};
    localparam int HALF_BIT_NS = BIT_PERIOD_NS / 2;
    
    //--------------------------------------------------------------------------
    // Driver Clocking Block
    //--------------------------------------------------------------------------
    clocking driver_cb @(posedge clk);
        default input #1ns output #1ns;
        output tx;
        input rx;
{% if has_rts_cts %}
        output rts;
        input cts;
{% endif %}
    endclocking
    
    //--------------------------------------------------------------------------
    // Monitor Clocking Block
    //--------------------------------------------------------------------------
    clocking monitor_cb @(posedge clk);
        default input #1ns output #0ns;
        input tx;
        input rx;
{% if has_rts_cts %}
        input rts;
        input cts;
{% endif %}
    endclocking
    
    //--------------------------------------------------------------------------
    // Modports
    //--------------------------------------------------------------------------
    modport driver_mp(clocking driver_cb, input clk, rst_n);
    modport monitor_mp(clocking monitor_cb, input clk, rst_n);
    
    //--------------------------------------------------------------------------
    // Tasks for Serial Communication
    //--------------------------------------------------------------------------
    
    // Transmit a byte (called by driver)
    task automatic transmit_byte(input logic [7:0] data, input parity_type_e parity);
        logic parity_bit;
        
        // Calculate parity
        case (parity)
            PARITY_EVEN:  parity_bit = ^data;
            PARITY_ODD:   parity_bit = ~(^data);
            PARITY_MARK:  parity_bit = 1'b1;
            PARITY_SPACE: parity_bit = 1'b0;
            default:      parity_bit = 1'b0;
        endcase
        
        // Start bit (low)
        tx = 1'b0;
        #(BIT_PERIOD_NS * 1ns);
        
        // Data bits (LSB first)
        for (int i = 0; i < {{ data_bits }}; i++) begin
            tx = data[i];
            #(BIT_PERIOD_NS * 1ns);
        end
        
        // Parity bit (if enabled)
        if (parity != PARITY_NONE) begin
            tx = parity_bit;
            #(BIT_PERIOD_NS * 1ns);
        end
        
        // Stop bit(s)
        tx = 1'b1;
        #({{ stop_bits }} * BIT_PERIOD_NS * 1ns);
    endtask
    
    // Receive a byte (called by monitor)
    task automatic receive_byte(output logic [7:0] data, output uart_error_e error);
        logic [{{ data_bits }}-1:0] rx_data;
        logic start_bit;
        
        error = ERR_NONE;
        data = '0;
        
        // Wait for start bit
        @(negedge rx);
        
        // Sample at middle of start bit
        #(HALF_BIT_NS * 1ns);
        start_bit = rx;
        
        if (start_bit != 1'b0) begin
            error = ERR_FRAME;
            return;
        end
        
        // Sample data bits
        for (int i = 0; i < {{ data_bits }}; i++) begin
            #(BIT_PERIOD_NS * 1ns);
            rx_data[i] = rx;
        end
        
        // Skip parity if present
{% if parity != 'none' %}
        #(BIT_PERIOD_NS * 1ns);
        // TODO: Check parity
{% endif %}
        
        // Check stop bit
        #(BIT_PERIOD_NS * 1ns);
        if (rx != 1'b1) begin
            error = ERR_FRAME;
        end
        
        data = rx_data;
    endtask
    
    //--------------------------------------------------------------------------
    // Assertions
    //--------------------------------------------------------------------------
    
    // Check that TX line is idle (high) when not transmitting
    property tx_idle_high;
        @(posedge clk) disable iff (!rst_n)
        $stable(tx) && tx == 1'b1;
    endproperty
    
{% if has_rts_cts %}
    // Check RTS/CTS handshaking
    property rts_before_tx;
        @(posedge clk) disable iff (!rst_n)
        $fell(tx) |-> cts == 1'b0;
    endproperty
{% endif %}
    
endinterface : uart_if
