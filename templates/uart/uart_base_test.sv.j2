//------------------------------------------------------------------------------
// UART Base Test
// Auto-generated by VerifAI
//------------------------------------------------------------------------------

class uart_base_test extends uvm_test;
    
    `uvm_component_utils(uart_base_test)
    
    //--------------------------------------------------------------------------
    // Environment
    //--------------------------------------------------------------------------
    
    uart_env env;
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "uart_base_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        env = uart_env::type_id::create("env", this);
    endfunction
    
    //--------------------------------------------------------------------------
    // End of Elaboration Phase
    //--------------------------------------------------------------------------
    
    function void end_of_elaboration_phase(uvm_phase phase);
        super.end_of_elaboration_phase(phase);
        
        // Print topology
        `uvm_info("TEST", "Testbench Topology:", UVM_NONE)
        uvm_top.print_topology();
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        
        `uvm_info("TEST", "Starting UART base test", UVM_MEDIUM)
        
        // Default: Run a simple random sequence
        run_default_sequence();
        
        // Allow time for all transactions to complete
        #1us;
        
        phase.drop_objection(this);
    endtask
    
    //--------------------------------------------------------------------------
    // Default Sequence
    //--------------------------------------------------------------------------
    
    virtual task run_default_sequence();
        uart_random_tx_seq seq;
        
        seq = uart_random_tx_seq::type_id::create("seq");
        seq.num_bytes = 10;
        seq.start(env.agent.sequencer);
    endtask
    
    //--------------------------------------------------------------------------
    // Report Phase
    //--------------------------------------------------------------------------
    
    function void report_phase(uvm_phase phase);
        uvm_report_server server;
        int error_count;
        
        super.report_phase(phase);
        
        server = uvm_report_server::get_server();
        error_count = server.get_severity_count(UVM_ERROR);
        
        `uvm_info("TEST", "========================================", UVM_NONE)
        if (error_count == 0) begin
            `uvm_info("TEST", "           TEST PASSED", UVM_NONE)
        end else begin
            `uvm_info("TEST", $sformatf("    TEST FAILED (%0d errors)", error_count), UVM_NONE)
        end
        `uvm_info("TEST", "========================================", UVM_NONE)
    endfunction
    
endclass : uart_base_test

//==============================================================================
// Random Test
//==============================================================================

class uart_random_test extends uart_base_test;
    
    `uvm_component_utils(uart_random_test)
    
    function new(string name = "uart_random_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    task run_default_sequence();
        uart_random_tx_seq seq;
        
        seq = uart_random_tx_seq::type_id::create("seq");
        seq.num_bytes = 100;
        seq.start(env.agent.sequencer);
    endtask
    
endclass : uart_random_test

//==============================================================================
// String Test
//==============================================================================

class uart_string_test extends uart_base_test;
    
    `uvm_component_utils(uart_string_test)
    
    function new(string name = "uart_string_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    task run_default_sequence();
        uart_string_tx_seq seq;
        
        seq = uart_string_tx_seq::type_id::create("seq");
        seq.tx_string = "Hello UART World!";
        seq.start(env.agent.sequencer);
    endtask
    
endclass : uart_string_test

//==============================================================================
// All Bytes Test
//==============================================================================

class uart_all_bytes_test extends uart_base_test;
    
    `uvm_component_utils(uart_all_bytes_test)
    
    function new(string name = "uart_all_bytes_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    task run_default_sequence();
        uart_all_bytes_tx_seq seq;
        
        seq = uart_all_bytes_tx_seq::type_id::create("seq");
        seq.start(env.agent.sequencer);
    endtask
    
endclass : uart_all_bytes_test

//==============================================================================
// Error Injection Test
//==============================================================================

class uart_error_test extends uart_base_test;
    
    `uvm_component_utils(uart_error_test)
    
    function new(string name = "uart_error_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    task run_default_sequence();
        uart_error_seq err_seq;
        uart_random_tx_seq normal_seq;
        
        // First some normal traffic
        normal_seq = uart_random_tx_seq::type_id::create("normal_seq");
        normal_seq.num_bytes = 5;
        normal_seq.start(env.agent.sequencer);
        
        // Frame error
        `uvm_info("TEST", "Injecting frame error", UVM_MEDIUM)
        err_seq = uart_error_seq::type_id::create("err_seq");
        err_seq.do_frame_error = 1;
        err_seq.do_parity_error = 0;
        err_seq.do_break = 0;
        err_seq.start(env.agent.sequencer);
        
        // More normal traffic
        normal_seq.start(env.agent.sequencer);
        
{% if parity != 'none' %}
        // Parity error
        `uvm_info("TEST", "Injecting parity error", UVM_MEDIUM)
        err_seq.do_frame_error = 0;
        err_seq.do_parity_error = 1;
        err_seq.start(env.agent.sequencer);
        
        normal_seq.start(env.agent.sequencer);
{% endif %}
        
        // Break condition
        `uvm_info("TEST", "Injecting break condition", UVM_MEDIUM)
        err_seq.do_frame_error = 0;
        err_seq.do_parity_error = 0;
        err_seq.do_break = 1;
        err_seq.start(env.agent.sequencer);
        
        normal_seq.start(env.agent.sequencer);
    endtask
    
endclass : uart_error_test
