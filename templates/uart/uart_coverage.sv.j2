//------------------------------------------------------------------------------
// UART Coverage
// Auto-generated by VerifAI
//------------------------------------------------------------------------------

class uart_coverage extends uvm_subscriber #(uart_seq_item);
    
    `uvm_component_utils(uart_coverage)
    
    //--------------------------------------------------------------------------
    // Coverage Groups
    //--------------------------------------------------------------------------
    
    covergroup uart_cg with function sample(uart_seq_item item);
        
        // Data value coverage
        data_cp: coverpoint item.data {
            bins zero = {8'h00};
            bins ones = {8'hFF};
            bins low[16] = {[8'h01:8'h0F]};
            bins mid[16] = {[8'h10:8'hEF]};
            bins high[16] = {[8'hF0:8'hFE]};
            bins special[] = {8'h55, 8'hAA, 8'h0D, 8'h0A};  // Patterns
        }
        
        // Operation type coverage
        op_cp: coverpoint item.op {
            bins tx = {UART_TX};
            bins rx = {UART_RX};
        }
        
        // Parity configuration coverage
        parity_cp: coverpoint item.parity {
            bins none = {PARITY_NONE};
            bins even = {PARITY_EVEN};
            bins odd = {PARITY_ODD};
            bins mark = {PARITY_MARK};
            bins space = {PARITY_SPACE};
        }
        
        // Baud rate coverage
        baud_cp: coverpoint item.baud_rate {
            bins slow = {9600, 19200};
            bins medium = {38400, 57600};
            bins fast = {115200};
            bins very_fast = {[230400:$]};
        }
        
        // Error coverage
        frame_err_cp: coverpoint item.inject_frame_error {
            bins no_error = {0};
            bins error = {1};
        }
        
        parity_err_cp: coverpoint item.inject_parity_error {
            bins no_error = {0};
            bins error = {1};
        }
        
        break_cp: coverpoint item.inject_break {
            bins no_break = {0};
            bins do_break = {1};
        }
        
        // Error detection coverage
        error_detected_cp: coverpoint item.error {
            bins none = {ERR_NONE};
            bins frame = {ERR_FRAME};
            bins parity = {ERR_PARITY};
            bins overrun = {ERR_OVERRUN};
            bins brk = {ERR_BREAK};
        }
        
        //----------------------------------------------------------------------
        // Cross Coverage
        //----------------------------------------------------------------------
        
        // Data patterns at different baud rates
        data_x_baud: cross data_cp, baud_cp;
        
        // Operations with different parity settings
        op_x_parity: cross op_cp, parity_cp;
        
        // Error injection combinations
        error_inject: cross frame_err_cp, parity_err_cp, break_cp {
            // Most common is no errors
            bins normal = binsof(frame_err_cp.no_error) && 
                         binsof(parity_err_cp.no_error) && 
                         binsof(break_cp.no_break);
        }
        
    endgroup
    
    //--------------------------------------------------------------------------
    // Special Character Coverage
    //--------------------------------------------------------------------------
    
    covergroup special_chars_cg with function sample(uart_seq_item item);
        
        ascii_ctrl_cp: coverpoint item.data {
            bins null_char = {8'h00};
            bins soh = {8'h01};  // Start of Header
            bins stx = {8'h02};  // Start of Text
            bins etx = {8'h03};  // End of Text
            bins eot = {8'h04};  // End of Transmission
            bins enq = {8'h05};  // Enquiry
            bins ack = {8'h06};  // Acknowledge
            bins bel = {8'h07};  // Bell
            bins bs = {8'h08};   // Backspace
            bins ht = {8'h09};   // Horizontal Tab
            bins lf = {8'h0A};   // Line Feed
            bins vt = {8'h0B};   // Vertical Tab
            bins ff = {8'h0C};   // Form Feed
            bins cr = {8'h0D};   // Carriage Return
            bins nak = {8'h15};  // Negative Acknowledge
            bins esc = {8'h1B};  // Escape
            bins del = {8'h7F};  // Delete
        }
        
        printable_cp: coverpoint item.data {
            bins space = {8'h20};
            bins digits = {[8'h30:8'h39]};
            bins upper_case = {[8'h41:8'h5A]};
            bins lower_case = {[8'h61:8'h7A]};
            bins punctuation = {[8'h21:8'h2F], [8'h3A:8'h40], [8'h5B:8'h60], [8'h7B:8'h7E]};
        }
        
    endgroup
    
    //--------------------------------------------------------------------------
    // Instance Variables
    //--------------------------------------------------------------------------
    
    uart_cg cg;
    special_chars_cg special_cg;
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "uart_coverage", uvm_component parent = null);
        super.new(name, parent);
        cg = new();
        special_cg = new();
    endfunction
    
    //--------------------------------------------------------------------------
    // Write (Sample Coverage)
    //--------------------------------------------------------------------------
    
    function void write(uart_seq_item t);
        cg.sample(t);
        special_cg.sample(t);
    endfunction
    
    //--------------------------------------------------------------------------
    // Report Phase
    //--------------------------------------------------------------------------
    
    function void report_phase(uvm_phase phase);
        super.report_phase(phase);
        
        `uvm_info("UART_COV", "========== UART Coverage Report ==========", UVM_NONE)
        `uvm_info("UART_COV", $sformatf("Main Coverage:     %.2f%%", cg.get_coverage()), UVM_NONE)
        `uvm_info("UART_COV", $sformatf("Special Chars:     %.2f%%", special_cg.get_coverage()), UVM_NONE)
        `uvm_info("UART_COV", "==========================================", UVM_NONE)
    endfunction
    
endclass : uart_coverage
