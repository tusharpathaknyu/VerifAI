//------------------------------------------------------------------------------
// UART Driver
// Auto-generated by VerifAI
//------------------------------------------------------------------------------

class uart_driver extends uvm_driver #(uart_seq_item);
    
    `uvm_component_utils(uart_driver)
    
    //--------------------------------------------------------------------------
    // Virtual Interface
    //--------------------------------------------------------------------------
    
    virtual uart_if vif;
    
    //--------------------------------------------------------------------------
    // Configuration
    //--------------------------------------------------------------------------
    
    int bit_period_ns = {{ bit_period_ns }};
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "uart_driver", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        if (!uvm_config_db#(virtual uart_if)::get(this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    task run_phase(uvm_phase phase);
        uart_seq_item item;
        
        // Initialize TX line high (idle)
        vif.tx = 1'b1;
        
        forever begin
            seq_item_port.get_next_item(item);
            drive_item(item);
            seq_item_port.item_done();
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Drive Transaction
    //--------------------------------------------------------------------------
    
    task drive_item(uart_seq_item item);
        `uvm_info("UART_DRV", $sformatf("Driving: %s", item.convert2string()), UVM_MEDIUM)
        
        item.start_time = $time;
        
        // Calculate bit period based on baud rate
        bit_period_ns = 1_000_000_000 / item.baud_rate;
        
{% if has_rts_cts %}
        // Wait for CTS if flow control enabled
        wait(vif.cts == 1'b0);
{% endif %}
        
        if (item.op == UART_TX) begin
            // Transmit operation
            if (item.inject_break) begin
                drive_break();
            end else begin
                drive_byte(item.data, item.parity, item.inject_frame_error, item.inject_parity_error);
            end
        end
        
        item.end_time = $time;
    endtask
    
    //--------------------------------------------------------------------------
    // Drive a Byte
    //--------------------------------------------------------------------------
    
    task drive_byte(logic [{{ data_bits }}-1:0] data, parity_type_e parity, bit frame_err, bit parity_err);
        logic parity_bit;
        
        // Calculate parity
        case (parity)
            PARITY_EVEN:  parity_bit = ^data;
            PARITY_ODD:   parity_bit = ~(^data);
            PARITY_MARK:  parity_bit = 1'b1;
            PARITY_SPACE: parity_bit = 1'b0;
            default:      parity_bit = 1'b0;
        endcase
        
        // Inject parity error
        if (parity_err)
            parity_bit = ~parity_bit;
        
        `uvm_info("UART_DRV", $sformatf("TX Start: data=0x%02h, bit_period=%0dns", data, bit_period_ns), UVM_HIGH)
        
        // Start bit (low)
        vif.tx = 1'b0;
        #(bit_period_ns * 1ns);
        
        // Data bits (LSB first)
        for (int i = 0; i < {{ data_bits }}; i++) begin
            vif.tx = data[i];
            #(bit_period_ns * 1ns);
        end
        
        // Parity bit (if enabled)
        if (parity != PARITY_NONE) begin
            vif.tx = parity_bit;
            #(bit_period_ns * 1ns);
        end
        
        // Stop bit (inject frame error by keeping low)
        if (frame_err) begin
            vif.tx = 1'b0;  // Invalid stop bit
        end else begin
            vif.tx = 1'b1;  // Valid stop bit
        end
        #(bit_period_ns * {{ stop_bits }} * 1ns);
        
        // Return to idle
        vif.tx = 1'b1;
        
        `uvm_info("UART_DRV", "TX Complete", UVM_HIGH)
    endtask
    
    //--------------------------------------------------------------------------
    // Drive Break Condition
    //--------------------------------------------------------------------------
    
    task drive_break();
        `uvm_info("UART_DRV", "Driving BREAK condition", UVM_MEDIUM)
        
        // Break is TX held low for > frame time
        vif.tx = 1'b0;
        #(bit_period_ns * ({{ frame_bits }} + 2) * 1ns);
        
        // Return to idle
        vif.tx = 1'b1;
        #(bit_period_ns * 1ns);
    endtask
    
endclass : uart_driver
