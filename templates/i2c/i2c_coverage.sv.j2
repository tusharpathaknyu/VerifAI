//------------------------------------------------------------------------------
// I2C Functional Coverage
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef I2C_COVERAGE_SV
`define I2C_COVERAGE_SV

class i2c_coverage extends uvm_subscriber #(i2c_seq_item);
    
    `uvm_component_utils(i2c_coverage)
    
    //--------------------------------------------------------------------------
    // Transaction Reference
    //--------------------------------------------------------------------------
    i2c_seq_item item;
    
    //--------------------------------------------------------------------------
    // Coverage Groups
    //--------------------------------------------------------------------------
    
    // Command Coverage
    covergroup i2c_cmd_cg;
        option.per_instance = 1;
        option.name = "i2c_command_coverage";
        
        // Read/Write operation
        cp_rw: coverpoint item.rw {
            bins write = {I2C_WRITE};
            bins read  = {I2C_READ};
        }
        
        // Transaction result
        cp_result: coverpoint item.result {
            bins ack  = {I2C_ACK};
            bins nack = {I2C_NACK};
        }
        
        // Number of bytes
        cp_num_bytes: coverpoint item.num_bytes {
            bins single = {1};
            bins small  = {[2:4]};
            bins medium = {[5:16]};
            bins large  = {[17:64]};
            bins burst  = {[65:$]};
        }
        
        // Cross coverage
        cx_rw_result: cross cp_rw, cp_result;
        cx_rw_bytes: cross cp_rw, cp_num_bytes;
    endgroup
    
    // Address Coverage
    covergroup i2c_addr_cg;
        option.per_instance = 1;
        option.name = "i2c_address_coverage";
        
        // 7-bit address ranges
        cp_slave_addr: coverpoint item.slave_addr {
            bins general_call = {7'h00};
            bins reserved_low = {[7'h01:7'h07]};
            bins normal       = {[7'h08:7'h77]};
            bins reserved_hi  = {[7'h78:7'h7F]};
        }
        
        // Common device addresses
        cp_common_devices: coverpoint item.slave_addr {
            bins eeprom_24c02    = {7'h50};
            bins eeprom_range    = {[7'h50:7'h57]};
            bins rtc_ds1307      = {7'h68};
            bins temp_lm75       = {[7'h48:7'h4F]};
            bins adc_ads1115     = {[7'h48:7'h4B]};
            bins gpio_pcf8574    = {[7'h20:7'h27]};
            bins lcd_pcf8574     = {7'h27, 7'h3F};
            bins oled_ssd1306    = {7'h3C, 7'h3D};
            bins accel_mpu6050   = {7'h68, 7'h69};
            ignore_bins other    = default;
        }
    endgroup
    
    // Data Coverage
    covergroup i2c_data_cg;
        option.per_instance = 1;
        option.name = "i2c_data_coverage";
        
        // First data byte patterns
        cp_first_byte: coverpoint item.data[0] iff (item.data.size() > 0) {
            bins all_zeros = {8'h00};
            bins all_ones  = {8'hFF};
            bins low_nibble= {[8'h01:8'h0F]};
            bins mid_range = {[8'h10:8'hEF]};
            bins high_vals = {[8'hF0:8'hFE]};
        }
        
        // Data byte transitions (when applicable)
        cp_data_pattern: coverpoint get_data_pattern() {
            bins constant    = {0};
            bins incrementing= {1};
            bins decrementing= {2};
            bins random      = {3};
        }
    endgroup
    
    // Timing Coverage
    covergroup i2c_timing_cg;
        option.per_instance = 1;
        option.name = "i2c_timing_coverage";
        
        // Clock stretching
        cp_clock_stretch: coverpoint item.clock_stretch_cycles {
            bins none    = {0};
            bins short_s = {[1:10]};
            bins medium_s= {[11:100]};
            bins long_s  = {[101:$]};
        }
        
        // Repeated start
        cp_repeated_start: coverpoint item.use_repeated_start {
            bins no_rep  = {0};
            bins rep     = {1};
        }
    endgroup
    
    // Protocol Coverage
    covergroup i2c_protocol_cg;
        option.per_instance = 1;
        option.name = "i2c_protocol_coverage";
        
        // Transaction type
        cp_trans_type: coverpoint item.trans_type {
            bins quick_cmd     = {I2C_QUICK_CMD};
            bins byte_trans    = {I2C_BYTE};
            bins word_trans    = {I2C_WORD};
            bins block_trans   = {I2C_BLOCK};
            bins combined      = {I2C_COMBINED};
        }
        
        // Speed mode
        cp_speed: coverpoint item.speed_mode {
            bins standard  = {I2C_STANDARD};
            bins fast      = {I2C_FAST};
            bins fast_plus = {I2C_FAST_PLUS};
            bins high      = {I2C_HIGH_SPEED};
        }
    endgroup
    
    // Error Injection Coverage
    covergroup i2c_error_cg;
        option.per_instance = 1;
        option.name = "i2c_error_coverage";
        
        cp_inject_error: coverpoint item.inject_error {
            bins no_error = {0};
            bins error    = {1};
        }
        
        cp_error_type: coverpoint item.error_type iff (item.inject_error) {
            bins nack_addr  = {I2C_ERR_NACK_ADDR};
            bins nack_data  = {I2C_ERR_NACK_DATA};
            bins arb_lost   = {I2C_ERR_ARB_LOST};
            bins timeout    = {I2C_ERR_TIMEOUT};
            bins bus_error  = {I2C_ERR_BUS_ERROR};
        }
    endgroup
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "i2c_coverage", uvm_component parent = null);
        super.new(name, parent);
        i2c_cmd_cg = new();
        i2c_addr_cg = new();
        i2c_data_cg = new();
        i2c_timing_cg = new();
        i2c_protocol_cg = new();
        i2c_error_cg = new();
    endfunction
    
    //--------------------------------------------------------------------------
    // Write Method (from subscriber)
    //--------------------------------------------------------------------------
    
    virtual function void write(i2c_seq_item t);
        item = t;
        
        i2c_cmd_cg.sample();
        i2c_addr_cg.sample();
        
        if (item.data.size() > 0)
            i2c_data_cg.sample();
        
        i2c_timing_cg.sample();
        i2c_protocol_cg.sample();
        i2c_error_cg.sample();
    endfunction
    
    //--------------------------------------------------------------------------
    // Helper Functions
    //--------------------------------------------------------------------------
    
    // Determine data pattern type
    function int get_data_pattern();
        if (item.data.size() < 2)
            return 0; // Constant (single byte)
        
        bit is_const = 1;
        bit is_inc = 1;
        bit is_dec = 1;
        
        for (int i = 1; i < item.data.size(); i++) begin
            if (item.data[i] != item.data[i-1])
                is_const = 0;
            if (item.data[i] != item.data[i-1] + 1)
                is_inc = 0;
            if (item.data[i] != item.data[i-1] - 1)
                is_dec = 0;
        end
        
        if (is_const) return 0;
        if (is_inc) return 1;
        if (is_dec) return 2;
        return 3; // Random
    endfunction
    
    //--------------------------------------------------------------------------
    // Report Phase
    //--------------------------------------------------------------------------
    
    virtual function void report_phase(uvm_phase phase);
        string report;
        real cmd_cov, addr_cov, data_cov, timing_cov, proto_cov, err_cov;
        real total_cov;
        
        cmd_cov = i2c_cmd_cg.get_coverage();
        addr_cov = i2c_addr_cg.get_coverage();
        data_cov = i2c_data_cg.get_coverage();
        timing_cov = i2c_timing_cg.get_coverage();
        proto_cov = i2c_protocol_cg.get_coverage();
        err_cov = i2c_error_cg.get_coverage();
        
        total_cov = (cmd_cov + addr_cov + data_cov + timing_cov + proto_cov + err_cov) / 6.0;
        
        report = "\n";
        report = {report, "╔══════════════════════════════════════════════════════════════╗\n"};
        report = {report, "║                  I2C Coverage Report                         ║\n"};
        report = {report, "╠══════════════════════════════════════════════════════════════╣\n"};
        report = {report, $sformatf("║  Command Coverage    : %6.2f%%                             ║\n", cmd_cov)};
        report = {report, $sformatf("║  Address Coverage    : %6.2f%%                             ║\n", addr_cov)};
        report = {report, $sformatf("║  Data Coverage       : %6.2f%%                             ║\n", data_cov)};
        report = {report, $sformatf("║  Timing Coverage     : %6.2f%%                             ║\n", timing_cov)};
        report = {report, $sformatf("║  Protocol Coverage   : %6.2f%%                             ║\n", proto_cov)};
        report = {report, $sformatf("║  Error Coverage      : %6.2f%%                             ║\n", err_cov)};
        report = {report, "╠══════════════════════════════════════════════════════════════╣\n"};
        report = {report, $sformatf("║  TOTAL COVERAGE      : %6.2f%%                             ║\n", total_cov)};
        report = {report, "╚══════════════════════════════════════════════════════════════╝\n"};
        
        `uvm_info("I2C_COV", report, UVM_LOW)
    endfunction
    
endclass : i2c_coverage

`endif // I2C_COVERAGE_SV
