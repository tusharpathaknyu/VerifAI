//------------------------------------------------------------------------------
// I2C Sequence Library
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef I2C_SEQUENCE_LIB_SV
`define I2C_SEQUENCE_LIB_SV

//==============================================================================
// Base I2C Sequence
//==============================================================================

class i2c_base_sequence extends uvm_sequence #(i2c_seq_item);
    
    `uvm_object_utils(i2c_base_sequence)
    
    // Default configuration
    logic [I2C_ADDR_WIDTH-1:0] target_addr = {{ i2c_device_addr | default("7'h50") }};
    i2c_speed_t seq_speed = I2C_STANDARD;
    
    function new(string name = "i2c_base_sequence");
        super.new(name);
    endfunction
    
    virtual task pre_body();
        if (starting_phase != null)
            starting_phase.raise_objection(this, {"Running: ", get_full_name()});
    endtask
    
    virtual task post_body();
        if (starting_phase != null)
            starting_phase.drop_objection(this, {"Completed: ", get_full_name()});
    endtask
    
endclass : i2c_base_sequence

//==============================================================================
// Single Byte Write Sequence
//==============================================================================

class i2c_single_write_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_single_write_seq)
    
    rand logic [7:0] write_data;
    
    function new(string name = "i2c_single_write_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        
        item = i2c_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            slave_addr == local::target_addr;
            rw == I2C_WRITE;
            num_bytes == 1;
            data.size() == 1;
            data[0] == local::write_data;
            speed == local::seq_speed;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        if (item.is_successful())
            `uvm_info("I2C_SEQ", $sformatf("Write 0x%02h to addr 0x%02h successful", 
                      write_data, target_addr), UVM_MEDIUM)
        else
            `uvm_warning("I2C_SEQ", $sformatf("Write to addr 0x%02h failed: %s", 
                        target_addr, item.result.name()))
    endtask
    
endclass : i2c_single_write_seq

//==============================================================================
// Single Byte Read Sequence
//==============================================================================

class i2c_single_read_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_single_read_seq)
    
    logic [7:0] read_data;
    
    function new(string name = "i2c_single_read_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        
        item = i2c_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            slave_addr == local::target_addr;
            rw == I2C_READ;
            num_bytes == 1;
            speed == local::seq_speed;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        if (item.is_successful() && item.rx_data.size() > 0) begin
            read_data = item.rx_data[0];
            `uvm_info("I2C_SEQ", $sformatf("Read 0x%02h from addr 0x%02h", 
                      read_data, target_addr), UVM_MEDIUM)
        end else begin
            `uvm_warning("I2C_SEQ", $sformatf("Read from addr 0x%02h failed", target_addr))
        end
    endtask
    
endclass : i2c_single_read_seq

//==============================================================================
// Multi-Byte Write Sequence
//==============================================================================

class i2c_burst_write_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_burst_write_seq)
    
    rand int unsigned num_bytes;
    rand logic [7:0] write_data[$];
    
    constraint c_num_bytes {
        num_bytes inside {[2:8]};
        write_data.size() == num_bytes;
    }
    
    function new(string name = "i2c_burst_write_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        
        item = i2c_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            slave_addr == local::target_addr;
            rw == I2C_WRITE;
            num_bytes == local::num_bytes;
            data.size() == local::num_bytes;
            foreach (data[i]) data[i] == local::write_data[i];
            speed == local::seq_speed;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        `uvm_info("I2C_SEQ", $sformatf("Burst write of %0d bytes to addr 0x%02h: %s", 
                  num_bytes, target_addr, item.result.name()), UVM_MEDIUM)
    endtask
    
endclass : i2c_burst_write_seq

//==============================================================================
// Multi-Byte Read Sequence
//==============================================================================

class i2c_burst_read_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_burst_read_seq)
    
    rand int unsigned num_bytes;
    logic [7:0] read_data[$];
    
    constraint c_num_bytes {
        num_bytes inside {[2:8]};
    }
    
    function new(string name = "i2c_burst_read_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        
        item = i2c_seq_item::type_id::create("item");
        
        start_item(item);
        if (!item.randomize() with {
            slave_addr == local::target_addr;
            rw == I2C_READ;
            num_bytes == local::num_bytes;
            speed == local::seq_speed;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        read_data = item.rx_data;
        `uvm_info("I2C_SEQ", $sformatf("Burst read of %0d bytes from addr 0x%02h: %s", 
                  num_bytes, target_addr, item.result.name()), UVM_MEDIUM)
    endtask
    
endclass : i2c_burst_read_seq

//==============================================================================
// Write-Read (EEPROM style) Sequence
//==============================================================================

class i2c_write_read_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_write_read_seq)
    
    rand logic [7:0] reg_addr;      // Register/memory address to write first
    rand int unsigned read_bytes;   // Number of bytes to read
    logic [7:0] read_data[$];
    
    constraint c_read_bytes {
        read_bytes inside {[1:4]};
    }
    
    function new(string name = "i2c_write_read_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item write_item, read_item;
        
        // First: Write the register address
        write_item = i2c_seq_item::type_id::create("write_item");
        
        start_item(write_item);
        if (!write_item.randomize() with {
            slave_addr == local::target_addr;
            rw == I2C_WRITE;
            num_bytes == 1;
            data.size() == 1;
            data[0] == local::reg_addr;
            gen_stop == 0;  // No STOP - use repeated START
            speed == local::seq_speed;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(write_item);
        
        if (!write_item.addr_ack) begin
            `uvm_warning("I2C_SEQ", "No ACK for address phase")
            return;
        end
        
        // Second: Read data with repeated START
        read_item = i2c_seq_item::type_id::create("read_item");
        
        start_item(read_item);
        if (!read_item.randomize() with {
            slave_addr == local::target_addr;
            rw == I2C_READ;
            num_bytes == local::read_bytes;
            gen_start == 1;  // Repeated START
            gen_stop == 1;
            speed == local::seq_speed;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(read_item);
        
        read_data = read_item.rx_data;
        `uvm_info("I2C_SEQ", $sformatf("Write-Read: wrote addr 0x%02h, read %0d bytes", 
                  reg_addr, read_data.size()), UVM_MEDIUM)
    endtask
    
endclass : i2c_write_read_seq

//==============================================================================
// Address Scan Sequence
//==============================================================================

class i2c_addr_scan_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_addr_scan_seq)
    
    logic [6:0] found_devices[$];
    
    function new(string name = "i2c_addr_scan_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        
        `uvm_info("I2C_SEQ", "Starting I2C address scan...", UVM_LOW)
        found_devices.delete();
        
        // Scan all valid 7-bit addresses
        for (int addr = 7'h08; addr <= 7'h77; addr++) begin
            item = i2c_seq_item::type_id::create($sformatf("scan_%02h", addr));
            
            start_item(item);
            if (!item.randomize() with {
                slave_addr == addr;
                rw == I2C_WRITE;
                num_bytes == 0;  // Just address phase
                data.size() == 0;
            }) begin
                `uvm_error("I2C_SEQ", "Randomization failed")
            end
            finish_item(item);
            
            if (item.addr_ack) begin
                found_devices.push_back(addr);
                `uvm_info("I2C_SEQ", $sformatf("Device found at address 0x%02h", addr), UVM_MEDIUM)
            end
        end
        
        `uvm_info("I2C_SEQ", $sformatf("Scan complete. Found %0d devices", found_devices.size()), UVM_LOW)
    endtask
    
endclass : i2c_addr_scan_seq

//==============================================================================
// NACK Test Sequence
//==============================================================================

class i2c_nack_test_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_nack_test_seq)
    
    function new(string name = "i2c_nack_test_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        logic [6:0] invalid_addr = 7'h7F;  // Reserved address - should NACK
        
        `uvm_info("I2C_SEQ", "Testing NACK handling with invalid address", UVM_LOW)
        
        item = i2c_seq_item::type_id::create("nack_item");
        
        start_item(item);
        if (!item.randomize() with {
            slave_addr == invalid_addr;
            rw == I2C_WRITE;
            num_bytes == 1;
        }) begin
            `uvm_error("I2C_SEQ", "Randomization failed")
        end
        finish_item(item);
        
        if (!item.addr_ack)
            `uvm_info("I2C_SEQ", "NACK correctly received for invalid address", UVM_MEDIUM)
        else
            `uvm_error("I2C_SEQ", "Unexpected ACK for invalid address")
    endtask
    
endclass : i2c_nack_test_seq

//==============================================================================
// Random Sequence
//==============================================================================

class i2c_random_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_random_seq)
    
    rand int unsigned num_transactions;
    
    constraint c_num_transactions {
        num_transactions inside {[5:20]};
    }
    
    function new(string name = "i2c_random_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        
        `uvm_info("I2C_SEQ", $sformatf("Running %0d random I2C transactions", num_transactions), UVM_LOW)
        
        for (int i = 0; i < num_transactions; i++) begin
            item = i2c_seq_item::type_id::create($sformatf("item_%0d", i));
            
            start_item(item);
            if (!item.randomize()) begin
                `uvm_error("I2C_SEQ", "Randomization failed")
            end
            finish_item(item);
            
            `uvm_info("I2C_SEQ", $sformatf("Transaction %0d: addr=0x%02h, %s, %0d bytes, result=%s", 
                      i, item.slave_addr, item.rw.name(), item.num_bytes, item.result.name()), UVM_HIGH)
        end
        
        `uvm_info("I2C_SEQ", "Random sequence complete", UVM_LOW)
    endtask
    
endclass : i2c_random_seq

//==============================================================================
// Speed Mode Test Sequence
//==============================================================================

class i2c_speed_test_seq extends i2c_base_sequence;
    
    `uvm_object_utils(i2c_speed_test_seq)
    
    function new(string name = "i2c_speed_test_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        i2c_seq_item item;
        i2c_speed_t speeds[$] = '{I2C_STANDARD, I2C_FAST, I2C_FAST_PLUS};
        
        `uvm_info("I2C_SEQ", "Testing all I2C speed modes", UVM_LOW)
        
        foreach (speeds[i]) begin
            item = i2c_seq_item::type_id::create($sformatf("speed_%0d", i));
            
            start_item(item);
            if (!item.randomize() with {
                slave_addr == local::target_addr;
                rw == I2C_WRITE;
                num_bytes == 4;
                speed == speeds[i];
            }) begin
                `uvm_error("I2C_SEQ", "Randomization failed")
            end
            finish_item(item);
            
            `uvm_info("I2C_SEQ", $sformatf("Speed mode %s: %s", 
                      speeds[i].name(), item.result.name()), UVM_MEDIUM)
        end
        
        `uvm_info("I2C_SEQ", "Speed mode test complete", UVM_LOW)
    endtask
    
endclass : i2c_speed_test_seq

`endif // I2C_SEQUENCE_LIB_SV
