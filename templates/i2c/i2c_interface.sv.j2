//------------------------------------------------------------------------------
// I2C Interface
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef I2C_INTERFACE_SV
`define I2C_INTERFACE_SV

interface i2c_if #(
    parameter int ADDR_WIDTH = {{ i2c_addr_bits | default(7) }}
)(
    input logic clk,
    input logic rst_n
);
    
    //--------------------------------------------------------------------------
    // I2C Signals (Active-low open-drain with pull-ups)
    //--------------------------------------------------------------------------
    wire        scl;      // Serial Clock Line
    wire        sda;      // Serial Data Line
    
    // Internal drive signals (directly drive low, release for high)
    logic       scl_o;    // SCL output (drive low when 0)
    logic       sda_o;    // SDA output (drive low when 0)
    logic       scl_oe;   // SCL output enable
    logic       sda_oe;   // SDA output enable
    
    // Pull-up resistor simulation
    assign scl = (scl_oe && !scl_o) ? 1'b0 : 1'bz;
    assign sda = (sda_oe && !sda_o) ? 1'b0 : 1'bz;
    
    // Pull-up to high when not driven low
    pullup(scl);
    pullup(sda);
    
    //--------------------------------------------------------------------------
    // Internal Monitoring Signals
    //--------------------------------------------------------------------------
    logic [7:0]  captured_byte;
    logic        start_detected;
    logic        stop_detected;
    logic        ack_detected;
    logic        nack_detected;
    i2c_state_t  bus_state;
    int          bit_count;
    
    //--------------------------------------------------------------------------
    // Clocking Blocks
    //--------------------------------------------------------------------------
    
    // Master clocking block
    clocking master_cb @(posedge clk);
        default input #1step output #1ns;
        inout  scl, sda;
        output scl_o, sda_o, scl_oe, sda_oe;
    endclocking
    
    // Slave clocking block
    clocking slave_cb @(posedge clk);
        default input #1step output #1ns;
        input  scl;
        inout  sda;
        output sda_o, sda_oe;
    endclocking
    
    // Monitor clocking block
    clocking mon_cb @(posedge clk);
        default input #1step;
        input scl, sda;
    endclocking
    
    //--------------------------------------------------------------------------
    // Modports
    //--------------------------------------------------------------------------
    modport master_mp (
        input  clk, rst_n,
        inout  scl, sda,
        output scl_o, sda_o, scl_oe, sda_oe
    );
    
    modport slave_mp (
        input  clk, rst_n, scl,
        inout  sda,
        output sda_o, sda_oe
    );
    
    modport monitor_mp (
        input clk, rst_n, scl, sda
    );
    
    //--------------------------------------------------------------------------
    // START Condition Detection
    //--------------------------------------------------------------------------
    always @(negedge sda) begin
        if (scl === 1'b1) begin
            start_detected <= 1'b1;
            bus_state <= I2C_START;
            @(posedge clk);
            start_detected <= 1'b0;
        end
    end
    
    //--------------------------------------------------------------------------
    // STOP Condition Detection
    //--------------------------------------------------------------------------
    always @(posedge sda) begin
        if (scl === 1'b1) begin
            stop_detected <= 1'b1;
            bus_state <= I2C_IDLE;
            @(posedge clk);
            stop_detected <= 1'b0;
        end
    end
    
    //--------------------------------------------------------------------------
    // Assertions
    //--------------------------------------------------------------------------
    
    // SDA should only change when SCL is low (except START/STOP)
    property sda_stable_when_scl_high;
        @(posedge clk) disable iff (!rst_n)
        (scl && !start_detected && !stop_detected) |-> $stable(sda);
    endproperty
    // Note: This is a soft check - real I2C may have glitches
    
    // Bus should not be stuck
    property bus_not_stuck;
        @(posedge clk) disable iff (!rst_n)
        (bus_state == I2C_IDLE) |-> ##[1:10000] (start_detected || bus_state != I2C_IDLE);
    endproperty
    
    //--------------------------------------------------------------------------
    // Coverage
    //--------------------------------------------------------------------------
    covergroup i2c_if_cg @(posedge clk);
        option.per_instance = 1;
        
        cp_scl: coverpoint scl {
            bins low  = {0};
            bins high = {1};
        }
        
        cp_sda: coverpoint sda {
            bins low  = {0};
            bins high = {1};
        }
        
        cp_state: coverpoint bus_state {
            bins idle     = {I2C_IDLE};
            bins start    = {I2C_START};
            bins addr     = {I2C_ADDR};
            bins data     = {I2C_DATA};
            bins ack      = {I2C_ACK_PHASE};
            bins stop     = {I2C_STOP};
            bins rep_start = {I2C_REP_START};
        }
    endgroup
    
    i2c_if_cg i2c_cov = new();
    
    //--------------------------------------------------------------------------
    // Tasks
    //--------------------------------------------------------------------------
    
    // Initialize interface
    task automatic init();
        scl_o  <= 1'b1;
        sda_o  <= 1'b1;
        scl_oe <= 1'b0;
        sda_oe <= 1'b0;
        bus_state <= I2C_IDLE;
        bit_count <= 0;
        start_detected <= 0;
        stop_detected <= 0;
    endtask
    
    // Wait for bus to be free
    task automatic wait_bus_free();
        wait(scl === 1'b1 && sda === 1'b1);
        repeat(T_BUF) @(posedge clk);
    endtask
    
    // Generate START condition
    task automatic generate_start();
        // Ensure bus is idle (both high)
        sda_oe <= 1'b0;  // Release SDA (high)
        scl_oe <= 1'b0;  // Release SCL (high)
        repeat(T_SU_STA) @(posedge clk);
        
        // Pull SDA low while SCL is high
        sda_o <= 1'b0;
        sda_oe <= 1'b1;
        repeat(T_HD_STA) @(posedge clk);
        
        // Pull SCL low
        scl_o <= 1'b0;
        scl_oe <= 1'b1;
    endtask
    
    // Generate STOP condition
    task automatic generate_stop();
        // Ensure SDA is low, SCL is low
        sda_o <= 1'b0;
        sda_oe <= 1'b1;
        scl_o <= 1'b0;
        scl_oe <= 1'b1;
        repeat(T_LOW) @(posedge clk);
        
        // Release SCL (goes high)
        scl_oe <= 1'b0;
        repeat(T_SU_STO) @(posedge clk);
        
        // Release SDA while SCL is high (STOP condition)
        sda_oe <= 1'b0;
        repeat(T_BUF) @(posedge clk);
    endtask
    
    // Transmit a byte (MSB first)
    task automatic transmit_byte(input logic [7:0] data, output logic ack);
        for (int i = 7; i >= 0; i--) begin
            // Set data while SCL is low
            sda_o <= data[i];
            sda_oe <= 1'b1;
            repeat(T_LOW/2) @(posedge clk);
            
            // Release SCL
            scl_oe <= 1'b0;
            repeat(T_HIGH) @(posedge clk);
            
            // Pull SCL low
            scl_o <= 1'b0;
            scl_oe <= 1'b1;
            repeat(T_LOW/2) @(posedge clk);
        end
        
        // ACK clock
        sda_oe <= 1'b0;  // Release SDA for ACK
        repeat(T_LOW/2) @(posedge clk);
        scl_oe <= 1'b0;  // Release SCL
        repeat(T_HIGH/2) @(posedge clk);
        ack = (sda === 1'b0);  // Read ACK
        repeat(T_HIGH/2) @(posedge clk);
        scl_o <= 1'b0;
        scl_oe <= 1'b1;
        repeat(T_LOW/2) @(posedge clk);
    endtask
    
    // Receive a byte
    task automatic receive_byte(output logic [7:0] data, input logic send_ack);
        data = 8'h00;
        sda_oe <= 1'b0;  // Release SDA to receive
        
        for (int i = 7; i >= 0; i--) begin
            repeat(T_LOW/2) @(posedge clk);
            scl_oe <= 1'b0;  // Release SCL
            repeat(T_HIGH/2) @(posedge clk);
            data[i] = sda;  // Sample data
            repeat(T_HIGH/2) @(posedge clk);
            scl_o <= 1'b0;
            scl_oe <= 1'b1;
            repeat(T_LOW/2) @(posedge clk);
        end
        
        // Send ACK/NACK
        sda_o <= send_ack ? 1'b0 : 1'b1;
        sda_oe <= 1'b1;
        repeat(T_LOW/2) @(posedge clk);
        scl_oe <= 1'b0;
        repeat(T_HIGH) @(posedge clk);
        scl_o <= 1'b0;
        scl_oe <= 1'b1;
        repeat(T_LOW/2) @(posedge clk);
    endtask
    
endinterface : i2c_if

`endif // I2C_INTERFACE_SV
