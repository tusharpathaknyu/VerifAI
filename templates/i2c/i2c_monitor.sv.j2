//------------------------------------------------------------------------------
// I2C Monitor
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef I2C_MONITOR_SV
`define I2C_MONITOR_SV

class i2c_monitor extends uvm_monitor;
    
    `uvm_component_utils(i2c_monitor)
    
    //--------------------------------------------------------------------------
    // Virtual Interface
    //--------------------------------------------------------------------------
    virtual i2c_if vif;
    
    //--------------------------------------------------------------------------
    // Analysis Ports
    //--------------------------------------------------------------------------
    uvm_analysis_port #(i2c_seq_item) item_collected_port;
    uvm_analysis_port #(i2c_seq_item) write_port;
    uvm_analysis_port #(i2c_seq_item) read_port;
    
    //--------------------------------------------------------------------------
    // Configuration
    //--------------------------------------------------------------------------
    bit checks_enable = 1;
    bit coverage_enable = 1;
    
    //--------------------------------------------------------------------------
    // Coverage
    //--------------------------------------------------------------------------
    i2c_seq_item collected_item;
    
    covergroup i2c_transaction_cg;
        option.per_instance = 1;
        
        cp_rw: coverpoint collected_item.rw {
            bins write = {I2C_WRITE};
            bins read  = {I2C_READ};
        }
        
        cp_addr: coverpoint collected_item.slave_addr {
            bins low_addr  = {[7'h08:7'h2F]};
            bins mid_addr  = {[7'h30:7'h5F]};
            bins high_addr = {[7'h60:7'h77]};
        }
        
        cp_num_bytes: coverpoint collected_item.num_bytes {
            bins single = {1};
            bins small  = {[2:4]};
            bins medium = {[5:8]};
            bins large  = {[9:16]};
        }
        
        cp_result: coverpoint collected_item.result {
            bins ack      = {I2C_ACK};
            bins nack     = {I2C_NACK};
            bins arb_lost = {I2C_ARB_LOST};
            bins timeout  = {I2C_TIMEOUT};
        }
        
        cp_speed: coverpoint collected_item.speed {
            bins standard  = {I2C_STANDARD};
            bins fast      = {I2C_FAST};
            bins fast_plus = {I2C_FAST_PLUS};
        }
        
        // Cross coverage
        rw_x_result: cross cp_rw, cp_result;
        rw_x_bytes: cross cp_rw, cp_num_bytes;
    endgroup
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "i2c_monitor", uvm_component parent = null);
        super.new(name, parent);
        item_collected_port = new("item_collected_port", this);
        write_port = new("write_port", this);
        read_port = new("read_port", this);
        i2c_transaction_cg = new();
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual i2c_if)::get(this, "", "vif", vif)) begin
            `uvm_fatal("I2C_MON", "Virtual interface not found in config DB")
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    virtual task run_phase(uvm_phase phase);
        collected_item = i2c_seq_item::type_id::create("collected_item");
        
        forever begin
            collect_transaction();
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Transaction Collection
    //--------------------------------------------------------------------------
    
    virtual task collect_transaction();
        i2c_seq_item item;
        logic [7:0] addr_byte;
        logic [7:0] data_byte;
        logic ack;
        int byte_count;
        
        item = i2c_seq_item::type_id::create("item");
        
        // Wait for START condition
        @(posedge vif.start_detected);
        item.gen_start = 1;
        `uvm_info("I2C_MON", "START condition detected", UVM_HIGH)
        
        // Capture address byte
        capture_byte(addr_byte, ack);
        item.slave_addr = addr_byte[7:1];
        item.rw = i2c_rw_t'(addr_byte[0]);
        item.addr_ack = ack;
        
        `uvm_info("I2C_MON", $sformatf("Address: 0x%02h, R/W: %s, ACK: %b", 
                  item.slave_addr, item.rw.name(), ack), UVM_HIGH)
        
        if (!ack) begin
            item.result = I2C_NACK;
            // Wait for STOP
            @(posedge vif.stop_detected);
            item.gen_stop = 1;
            finish_transaction(item);
            return;
        end
        
        // Capture data bytes until STOP or repeated START
        byte_count = 0;
        while (1) begin
            // Check for STOP or repeated START
            fork
                begin : stop_detect
                    @(posedge vif.stop_detected);
                    item.gen_stop = 1;
                end
                begin : rep_start_detect
                    @(posedge vif.start_detected);
                    item.gen_rep_start = 1;
                end
                begin : data_capture
                    capture_byte(data_byte, ack);
                    if (item.rw == I2C_WRITE)
                        item.data.push_back(data_byte);
                    else
                        item.rx_data.push_back(data_byte);
                    item.data_acks.push_back(ack);
                    byte_count++;
                end
            join_any
            disable fork;
            
            if (item.gen_stop || item.gen_rep_start)
                break;
                
            if (byte_count >= 256) begin  // Safety limit
                `uvm_warning("I2C_MON", "Exceeded maximum byte count")
                break;
            end
        end
        
        item.num_bytes = byte_count;
        item.result = I2C_ACK;
        
        finish_transaction(item);
    endtask
    
    //--------------------------------------------------------------------------
    // Capture Single Byte
    //--------------------------------------------------------------------------
    
    virtual task capture_byte(output logic [7:0] data, output logic ack);
        data = 8'h00;
        
        // Capture 8 data bits
        for (int i = 7; i >= 0; i--) begin
            @(posedge vif.scl);
            data[i] = vif.sda;
        end
        
        // Capture ACK bit
        @(posedge vif.scl);
        ack = (vif.sda === 1'b0);
        @(negedge vif.scl);
    endtask
    
    //--------------------------------------------------------------------------
    // Finish Transaction
    //--------------------------------------------------------------------------
    
    virtual task finish_transaction(i2c_seq_item item);
        // Update coverage reference and sample
        collected_item = item;
        if (coverage_enable) begin
            i2c_transaction_cg.sample();
        end
        
        // Protocol checks
        if (checks_enable) begin
            perform_checks(item);
        end
        
        // Send to analysis ports
        item_collected_port.write(item);
        if (item.rw == I2C_WRITE)
            write_port.write(item);
        else
            read_port.write(item);
        
        `uvm_info("I2C_MON", $sformatf("Collected transaction:\n%s", item.convert2string()), UVM_MEDIUM)
    endtask
    
    //--------------------------------------------------------------------------
    // Protocol Checks
    //--------------------------------------------------------------------------
    
    virtual function void perform_checks(i2c_seq_item item);
        // Check for valid address range
        if (item.slave_addr < 7'h08 || item.slave_addr > 7'h77) begin
            `uvm_warning("I2C_MON", $sformatf("Address 0x%02h is reserved", item.slave_addr))
        end
        
        // Check for missing STOP
        if (!item.gen_stop && !item.gen_rep_start) begin
            `uvm_warning("I2C_MON", "Transaction ended without STOP or repeated START")
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Report Phase
    //--------------------------------------------------------------------------
    
    virtual function void report_phase(uvm_phase phase);
        `uvm_info("I2C_MON", $sformatf("Coverage: %.2f%%", i2c_transaction_cg.get_coverage()), UVM_LOW)
    endfunction
    
endclass : i2c_monitor

`endif // I2C_MONITOR_SV
