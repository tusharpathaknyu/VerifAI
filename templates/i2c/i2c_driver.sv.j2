//------------------------------------------------------------------------------
// I2C Driver
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef I2C_DRIVER_SV
`define I2C_DRIVER_SV

class i2c_driver extends uvm_driver #(i2c_seq_item);
    
    `uvm_component_utils(i2c_driver)
    
    //--------------------------------------------------------------------------
    // Virtual Interface
    //--------------------------------------------------------------------------
    virtual i2c_if vif;
    
    //--------------------------------------------------------------------------
    // Configuration
    //--------------------------------------------------------------------------
    bit is_master = 1;
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "i2c_driver", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    //--------------------------------------------------------------------------
    // Build Phase
    //--------------------------------------------------------------------------
    
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual i2c_if)::get(this, "", "vif", vif)) begin
            `uvm_fatal("I2C_DRV", "Virtual interface not found in config DB")
        end
    endfunction
    
    //--------------------------------------------------------------------------
    // Run Phase
    //--------------------------------------------------------------------------
    
    virtual task run_phase(uvm_phase phase);
        i2c_seq_item req;
        
        // Initialize interface
        vif.init();
        
        // Wait for reset
        @(posedge vif.rst_n);
        repeat(10) @(posedge vif.clk);
        
        forever begin
            seq_item_port.get_next_item(req);
            `uvm_info("I2C_DRV", $sformatf("Driving transaction:\n%s", req.convert2string()), UVM_MEDIUM)
            
            if (is_master)
                drive_master_transfer(req);
            else
                drive_slave_transfer(req);
            
            seq_item_port.item_done();
        end
    endtask
    
    //--------------------------------------------------------------------------
    // Master Transfer
    //--------------------------------------------------------------------------
    
    virtual task drive_master_transfer(i2c_seq_item item);
        logic ack;
        logic [7:0] rx_byte;
        
        // Generate START if requested
        if (item.gen_start) begin
            vif.wait_bus_free();
            vif.generate_start();
            `uvm_info("I2C_DRV", "Generated START condition", UVM_HIGH)
        end
        
        // Send address byte
        vif.transmit_byte(item.get_addr_byte(), ack);
        item.addr_ack = ack;
        
        if (!ack) begin
            `uvm_warning("I2C_DRV", $sformatf("NACK received for address 0x%02h", item.slave_addr))
            item.result = I2C_NACK;
            if (item.gen_stop) vif.generate_stop();
            return;
        end
        
        `uvm_info("I2C_DRV", $sformatf("Address 0x%02h ACKed", item.slave_addr), UVM_HIGH)
        
        // Transfer data
        if (item.rw == I2C_WRITE) begin
            // Write operation
            foreach (item.data[i]) begin
                // Inter-byte delay
                repeat(item.inter_byte_delay) @(posedge vif.clk);
                
                vif.transmit_byte(item.data[i], ack);
                item.data_acks.push_back(ack);
                
                if (!ack) begin
                    `uvm_warning("I2C_DRV", $sformatf("NACK received for data byte %0d", i))
                    item.result = I2C_NACK;
                    break;
                end
                
                `uvm_info("I2C_DRV", $sformatf("Wrote 0x%02h, ACK=%b", item.data[i], ack), UVM_HIGH)
            end
        end else begin
            // Read operation
            for (int i = 0; i < item.num_bytes; i++) begin
                // Inter-byte delay
                repeat(item.inter_byte_delay) @(posedge vif.clk);
                
                // Send ACK for all bytes except the last one
                vif.receive_byte(rx_byte, (i < item.num_bytes - 1));
                item.rx_data.push_back(rx_byte);
                
                `uvm_info("I2C_DRV", $sformatf("Read 0x%02h, sent %s", 
                          rx_byte, (i < item.num_bytes - 1) ? "ACK" : "NACK"), UVM_HIGH)
            end
        end
        
        // Generate repeated START if requested
        if (item.gen_rep_start) begin
            vif.generate_start();
            `uvm_info("I2C_DRV", "Generated repeated START", UVM_HIGH)
        end
        
        // Generate STOP if requested
        if (item.gen_stop && !item.gen_rep_start) begin
            vif.generate_stop();
            `uvm_info("I2C_DRV", "Generated STOP condition", UVM_HIGH)
        end
        
        if (item.result != I2C_NACK)
            item.result = I2C_ACK;
        
    endtask
    
    //--------------------------------------------------------------------------
    // Slave Transfer (for slave agent)
    //--------------------------------------------------------------------------
    
    virtual task drive_slave_transfer(i2c_seq_item item);
        // Wait for START condition
        @(posedge vif.start_detected);
        
        // This is a simplified slave driver
        // A full implementation would handle address matching and respond accordingly
        `uvm_info("I2C_DRV", "Slave: START detected, waiting for address", UVM_HIGH)
        
        // The slave typically responds to what the master sends
        // For a complete slave implementation, you would:
        // 1. Wait for and decode the address byte
        // 2. Check if address matches
        // 3. Send ACK/NACK
        // 4. Send/receive data based on R/W bit
    endtask
    
endclass : i2c_driver

`endif // I2C_DRIVER_SV
