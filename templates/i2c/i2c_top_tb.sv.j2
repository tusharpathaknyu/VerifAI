//------------------------------------------------------------------------------
// I2C Top-Level Testbench
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`timescale 1ns/1ps

module i2c_top_tb;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import i2c_pkg::*;
    
    //--------------------------------------------------------------------------
    // Parameters
    //--------------------------------------------------------------------------
    parameter CLK_PERIOD = 10;  // 100MHz system clock
    
    // I2C timing parameters (Standard Mode = 100kHz)
    parameter I2C_CLK_PERIOD = 10000;  // 10us = 100kHz
    
    //--------------------------------------------------------------------------
    // Signals
    //--------------------------------------------------------------------------
    logic clk;
    logic rst_n;
    
    // I2C signals (directly connecting master and slave sides)
    wire  scl;
    wire  sda;
    
    // Pull-up resistor simulation
    logic scl_master_out = 1'b1;
    logic sda_master_out = 1'b1;
    logic scl_slave_out = 1'b1;
    logic sda_slave_out = 1'b1;
    
    //--------------------------------------------------------------------------
    // I2C Interface Instance
    //--------------------------------------------------------------------------
    i2c_if i2c_vif(
        .clk    (clk),
        .rst_n  (rst_n)
    );
    
    //--------------------------------------------------------------------------
    // Open-Drain Bus Simulation
    // I2C uses open-drain with pull-up resistors
    //--------------------------------------------------------------------------
    
    // SCL is driven low by either master or slave, otherwise pulled high
    assign scl = (scl_master_out & scl_slave_out) ? 1'b1 : 1'b0;
    
    // SDA is driven low by either master or slave, otherwise pulled high
    assign sda = (sda_master_out & sda_slave_out) ? 1'b1 : 1'b0;
    
    // Connect interface to bus
    assign i2c_vif.scl = scl;
    assign i2c_vif.sda = sda;
    
    //--------------------------------------------------------------------------
    // DUT Placeholder
    // Replace this with your actual I2C slave device
    //--------------------------------------------------------------------------
    
    // Simple I2C EEPROM model for testing
    i2c_eeprom_model #(
        .ADDR_WIDTH(7),
        .MEM_SIZE(256)
    ) dut_eeprom (
        .scl(scl),
        .sda(sda),
        .slave_addr(7'h50)
    );
    
    //--------------------------------------------------------------------------
    // Clock Generation
    //--------------------------------------------------------------------------
    
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    //--------------------------------------------------------------------------
    // Reset Generation
    //--------------------------------------------------------------------------
    
    initial begin
        rst_n = 0;
        #(CLK_PERIOD * 10);
        rst_n = 1;
        `uvm_info("TB_TOP", "Reset released", UVM_LOW)
    end
    
    //--------------------------------------------------------------------------
    // Interface Configuration
    //--------------------------------------------------------------------------
    
    initial begin
        // Set virtual interface in config_db
        uvm_config_db#(virtual i2c_if)::set(null, "*", "vif", i2c_vif);
        
        // Set timeout
        uvm_top.set_timeout(10ms, 0);
        
        `uvm_info("TB_TOP", "I2C Testbench initialized", UVM_LOW)
    end
    
    //--------------------------------------------------------------------------
    // UVM Test Entry Point
    //--------------------------------------------------------------------------
    
    initial begin
        run_test();
    end
    
    //--------------------------------------------------------------------------
    // Waveform Dumping
    //--------------------------------------------------------------------------
    
    initial begin
        if ($test$plusargs("WAVES")) begin
            $dumpfile("i2c_waves.vcd");
            $dumpvars(0, i2c_top_tb);
            `uvm_info("TB_TOP", "VCD waveform dumping enabled", UVM_LOW)
        end
    end
    
    //--------------------------------------------------------------------------
    // Protocol Assertions
    //--------------------------------------------------------------------------
    
    // START condition: SDA falls while SCL is high
    property p_start_condition;
        @(negedge sda) scl == 1'b1;
    endproperty
    
    // STOP condition: SDA rises while SCL is high
    property p_stop_condition;
        @(posedge sda) scl == 1'b1;
    endproperty
    
    // Data valid: SDA stable when SCL is high
    property p_data_valid;
        @(posedge scl) disable iff (!rst_n)
        ##1 $stable(sda) throughout (scl[*1:$] ##1 !scl);
    endproperty
    
    // Optional assertion checks (can be enabled/disabled)
    // assert_data_valid: assert property(p_data_valid)
    //     else `uvm_error("TB_TOP", "I2C data changed while SCL high")
    
endmodule : i2c_top_tb

//------------------------------------------------------------------------------
// Simple I2C EEPROM Model for Testing
//------------------------------------------------------------------------------

module i2c_eeprom_model #(
    parameter ADDR_WIDTH = 7,
    parameter MEM_SIZE = 256
)(
    input  wire       scl,
    inout  wire       sda,
    input  wire [6:0] slave_addr
);
    
    //--------------------------------------------------------------------------
    // Internal Signals
    //--------------------------------------------------------------------------
    logic sda_out = 1'b1;
    assign sda = sda_out ? 1'bz : 1'b0;
    
    logic [7:0] memory [0:MEM_SIZE-1];
    logic [7:0] addr_reg;
    logic [7:0] data_reg;
    
    typedef enum logic [3:0] {
        IDLE,
        GET_ADDR,
        CHECK_ADDR,
        SEND_ACK,
        GET_DATA,
        SEND_DATA,
        WAIT_ACK,
        WAIT_STOP
    } state_t;
    
    state_t state = IDLE;
    int bit_count = 0;
    logic [7:0] shift_reg;
    logic rw_bit;
    logic addr_match;
    
    //--------------------------------------------------------------------------
    // START/STOP Detection
    //--------------------------------------------------------------------------
    
    wire start_cond = (scl == 1'b1) && ($fell(sda));
    wire stop_cond  = (scl == 1'b1) && ($rose(sda));
    
    //--------------------------------------------------------------------------
    // I2C Slave State Machine
    //--------------------------------------------------------------------------
    
    always @(posedge scl or posedge start_cond or posedge stop_cond) begin
        if (start_cond) begin
            state <= GET_ADDR;
            bit_count <= 0;
            shift_reg <= 8'h00;
        end else if (stop_cond) begin
            state <= IDLE;
            sda_out <= 1'b1;
        end else if (scl) begin
            case (state)
                GET_ADDR: begin
                    shift_reg <= {shift_reg[6:0], sda};
                    bit_count <= bit_count + 1;
                    if (bit_count == 7) begin
                        rw_bit <= sda;
                        state <= CHECK_ADDR;
                    end
                end
                
                CHECK_ADDR: begin
                    addr_match = (shift_reg[7:1] == slave_addr);
                    if (addr_match) begin
                        state <= SEND_ACK;
                    end else begin
                        state <= IDLE;
                    end
                end
                
                GET_DATA: begin
                    shift_reg <= {shift_reg[6:0], sda};
                    bit_count <= bit_count + 1;
                    if (bit_count == 7) begin
                        state <= SEND_ACK;
                        // Store data at address
                        if (!rw_bit) begin
                            memory[addr_reg] <= {shift_reg[6:0], sda};
                            addr_reg <= addr_reg + 1;
                        end
                    end
                end
                
                SEND_DATA: begin
                    bit_count <= bit_count + 1;
                    if (bit_count == 7) begin
                        state <= WAIT_ACK;
                        addr_reg <= addr_reg + 1;
                    end
                end
                
                default: ;
            endcase
        end
    end
    
    //--------------------------------------------------------------------------
    // SDA Output Control
    //--------------------------------------------------------------------------
    
    always @(negedge scl) begin
        case (state)
            SEND_ACK: begin
                sda_out <= 1'b0;  // ACK
                bit_count <= 0;
                if (rw_bit) begin
                    state <= SEND_DATA;
                    data_reg <= memory[addr_reg];
                end else begin
                    state <= GET_DATA;
                end
            end
            
            SEND_DATA: begin
                sda_out <= data_reg[7];
                data_reg <= {data_reg[6:0], 1'b0};
            end
            
            WAIT_ACK: begin
                sda_out <= 1'b1;  // Release SDA
                state <= SEND_DATA;
                data_reg <= memory[addr_reg];
                bit_count <= 0;
            end
            
            default: begin
                sda_out <= 1'b1;  // Release SDA
            end
        endcase
    end
    
    //--------------------------------------------------------------------------
    // Memory Initialization
    //--------------------------------------------------------------------------
    
    initial begin
        // Initialize memory with incrementing pattern
        for (int i = 0; i < MEM_SIZE; i++) begin
            memory[i] = i;
        end
        addr_reg = 8'h00;
    end
    
endmodule : i2c_eeprom_model
