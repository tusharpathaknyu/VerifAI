//------------------------------------------------------------------------------
// I2C Sequence Item
// Generated by VerifAI - Natural Language to UVM Testbench Generator
//------------------------------------------------------------------------------

`ifndef I2C_SEQ_ITEM_SV
`define I2C_SEQ_ITEM_SV

class i2c_seq_item extends uvm_sequence_item;
    
    //--------------------------------------------------------------------------
    // Transaction Fields
    //--------------------------------------------------------------------------
    
    // Address and R/W
    rand logic [I2C_ADDR_WIDTH-1:0] slave_addr;
    rand i2c_rw_t                   rw;           // Read or Write
    
    // Data
    rand logic [7:0]                data[$];      // Data bytes
    rand int unsigned               num_bytes;    // Number of bytes
    
    // Control
    rand bit                        gen_start;    // Generate START
    rand bit                        gen_stop;     // Generate STOP
    rand bit                        gen_rep_start; // Generate repeated START
    
    // Response
    i2c_result_t                    result;       // Transfer result
    logic [7:0]                     rx_data[$];   // Received data
    bit                             addr_ack;     // Address ACK received
    bit                             data_acks[$]; // Data ACK for each byte
    
    // Timing
    rand int unsigned               inter_byte_delay;  // Delay between bytes
    rand i2c_speed_t                speed;
    
    //--------------------------------------------------------------------------
    // Constraints
    //--------------------------------------------------------------------------
    
    constraint c_num_bytes {
        num_bytes inside {[1:16]};
        data.size() == num_bytes;
    }
    
    constraint c_slave_addr {
        slave_addr inside {[7'h08:7'h77]};  // Valid 7-bit addresses
    }
    
    constraint c_start_stop {
        gen_start == 1;  // Usually start with START
        gen_stop == 1;   // Usually end with STOP
    }
    
    constraint c_inter_byte_delay {
        inter_byte_delay inside {[0:5]};
    }
    
    constraint c_speed {
        soft speed == I2C_STANDARD;
    }
    
    //--------------------------------------------------------------------------
    // UVM Automation
    //--------------------------------------------------------------------------
    
    `uvm_object_utils_begin(i2c_seq_item)
        `uvm_field_int(slave_addr, UVM_ALL_ON)
        `uvm_field_enum(i2c_rw_t, rw, UVM_ALL_ON)
        `uvm_field_queue_int(data, UVM_ALL_ON)
        `uvm_field_int(num_bytes, UVM_ALL_ON)
        `uvm_field_int(gen_start, UVM_ALL_ON)
        `uvm_field_int(gen_stop, UVM_ALL_ON)
        `uvm_field_int(gen_rep_start, UVM_ALL_ON)
        `uvm_field_enum(i2c_result_t, result, UVM_ALL_ON)
        `uvm_field_queue_int(rx_data, UVM_ALL_ON)
        `uvm_field_int(addr_ack, UVM_ALL_ON)
        `uvm_field_queue_int(data_acks, UVM_ALL_ON)
        `uvm_field_int(inter_byte_delay, UVM_ALL_ON)
        `uvm_field_enum(i2c_speed_t, speed, UVM_ALL_ON)
    `uvm_object_utils_end
    
    //--------------------------------------------------------------------------
    // Constructor
    //--------------------------------------------------------------------------
    
    function new(string name = "i2c_seq_item");
        super.new(name);
        result = I2C_ACK;
        addr_ack = 0;
    endfunction
    
    //--------------------------------------------------------------------------
    // Methods
    //--------------------------------------------------------------------------
    
    // Get address byte (7-bit addr + R/W bit)
    function logic [7:0] get_addr_byte();
        return {slave_addr[6:0], rw};
    endfunction
    
    // Convert to string for debug
    virtual function string convert2string();
        string s;
        s = $sformatf("\n========== I2C Transaction ==========\n");
        s = {s, $sformatf("  Slave Address : 0x%02h\n", slave_addr)};
        s = {s, $sformatf("  R/W           : %s\n", rw.name())};
        s = {s, $sformatf("  Num Bytes     : %0d\n", num_bytes)};
        s = {s, $sformatf("  Speed         : %s\n", speed.name())};
        s = {s, $sformatf("  START         : %0b\n", gen_start)};
        s = {s, $sformatf("  STOP          : %0b\n", gen_stop)};
        s = {s, $sformatf("  Result        : %s\n", result.name())};
        s = {s, $sformatf("  Addr ACK      : %0b\n", addr_ack)};
        
        if (rw == I2C_WRITE) begin
            s = {s, "  TX Data       : "};
            foreach (data[i]) s = {s, $sformatf("0x%02h ", data[i])};
        end else begin
            s = {s, "  RX Data       : "};
            foreach (rx_data[i]) s = {s, $sformatf("0x%02h ", rx_data[i])};
        end
        s = {s, "\n======================================\n"};
        return s;
    endfunction
    
    // Check if transaction completed successfully
    function bit is_successful();
        return (result == I2C_ACK) && addr_ack;
    endfunction
    
    // Deep copy
    virtual function void do_copy(uvm_object rhs);
        i2c_seq_item rhs_item;
        super.do_copy(rhs);
        if (!$cast(rhs_item, rhs)) begin
            `uvm_error("I2C_SEQ_ITEM", "Cast failed in do_copy")
            return;
        end
        this.slave_addr = rhs_item.slave_addr;
        this.rw = rhs_item.rw;
        this.data = rhs_item.data;
        this.num_bytes = rhs_item.num_bytes;
        this.gen_start = rhs_item.gen_start;
        this.gen_stop = rhs_item.gen_stop;
        this.gen_rep_start = rhs_item.gen_rep_start;
        this.result = rhs_item.result;
        this.rx_data = rhs_item.rx_data;
        this.addr_ack = rhs_item.addr_ack;
        this.data_acks = rhs_item.data_acks;
        this.inter_byte_delay = rhs_item.inter_byte_delay;
        this.speed = rhs_item.speed;
    endfunction
    
    // Compare
    virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
        i2c_seq_item rhs_item;
        if (!$cast(rhs_item, rhs)) return 0;
        return (super.do_compare(rhs, comparer) &&
                this.slave_addr == rhs_item.slave_addr &&
                this.rw == rhs_item.rw &&
                this.num_bytes == rhs_item.num_bytes);
    endfunction
    
endclass : i2c_seq_item

`endif // I2C_SEQ_ITEM_SV
