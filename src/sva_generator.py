"""
SVA (SystemVerilog Assertion) Generator
Automatically generates temporal properties and assertions from RTL analysis.

This is a KEY differentiator - generating meaningful SVA from RTL structure
that would take engineers hours to write manually.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Tuple
from enum import Enum
import re


class AssertionType(Enum):
    """Types of SVA assertions"""
    PROPERTY = "property"          # Reusable property
    ASSERT = "assert"              # Assert directive
    ASSUME = "assume"              # Assume for formal
    COVER = "cover"                # Cover for functional coverage


class AssertionCategory(Enum):
    """Categories of generated assertions"""
    PROTOCOL = "protocol"          # Protocol compliance (APB, AXI, etc.)
    HANDSHAKE = "handshake"        # Request/acknowledge patterns
    STABILITY = "stability"        # Signal stability requirements
    TIMING = "timing"              # Timing relationships
    FSM = "fsm"                    # State machine properties
    DATA_INTEGRITY = "data"        # Data path checks
    RESET = "reset"                # Reset behavior
    CLOCK_DOMAIN = "cdc"           # Clock domain crossing
    FIFO = "fifo"                  # FIFO properties
    ARBITER = "arbiter"            # Arbitration logic


@dataclass
class SVAProperty:
    """Represents a generated SVA property/assertion"""
    name: str
    description: str
    category: AssertionCategory
    assertion_type: AssertionType
    code: str
    severity: str = "error"        # error, warning, info
    formal_friendly: bool = True   # Can be used in formal verification
    
    def to_sv(self) -> str:
        """Generate SystemVerilog code"""
        lines = [f"  // {self.description}"]
        if self.assertion_type == AssertionType.PROPERTY:
            lines.append(f"  property {self.name};")
            lines.append(f"    {self.code}")
            lines.append(f"  endproperty")
            lines.append(f"  {self.name}_assert: assert property ({self.name})")
            lines.append(f"    else $error(\"[SVA] {self.name} failed\");")
        elif self.assertion_type == AssertionType.ASSERT:
            lines.append(f"  {self.name}: assert property ({self.code})")
            lines.append(f"    else ${self.severity}(\"[SVA] {self.name} failed\");")
        elif self.assertion_type == AssertionType.ASSUME:
            lines.append(f"  {self.name}: assume property ({self.code});")
        elif self.assertion_type == AssertionType.COVER:
            lines.append(f"  {self.name}: cover property ({self.code});")
        return "\n".join(lines)


@dataclass
class SVAModule:
    """Collection of SVA assertions for a module"""
    module_name: str
    clock: str = "clk"
    reset: str = "rst_n"
    reset_active_low: bool = True
    properties: List[SVAProperty] = field(default_factory=list)
    
    def to_sv(self) -> str:
        """Generate complete SVA bind module"""
        reset_condition = f"!{self.reset}" if self.reset_active_low else self.reset
        
        lines = [
            f"// Auto-generated SVA assertions for {self.module_name}",
            f"// Generated by VerifAI - https://github.com/tusharpathaknyu/VerifAI",
            f"",
            f"module {self.module_name}_sva",
            f"  import uvm_pkg::*;",
            f"  (",
        ]
        
        # Add port declarations (to be filled based on RTL analysis)
        lines.append(f"    input logic {self.clock},")
        lines.append(f"    input logic {self.reset}")
        lines.append(f"    // Additional ports added during binding")
        lines.append(f"  );")
        lines.append(f"")
        lines.append(f"  // Default clocking block")
        lines.append(f"  default clocking cb @(posedge {self.clock});")
        lines.append(f"  endclocking")
        lines.append(f"")
        lines.append(f"  // Default disable during reset")
        lines.append(f"  default disable iff ({reset_condition});")
        lines.append(f"")
        
        # Group by category
        by_category: Dict[AssertionCategory, List[SVAProperty]] = {}
        for prop in self.properties:
            if prop.category not in by_category:
                by_category[prop.category] = []
            by_category[prop.category].append(prop)
        
        for category, props in by_category.items():
            lines.append(f"  // {'='*60}")
            lines.append(f"  // {category.value.upper()} ASSERTIONS")
            lines.append(f"  // {'='*60}")
            for prop in props:
                lines.append(prop.to_sv())
                lines.append("")
        
        lines.append(f"endmodule : {self.module_name}_sva")
        lines.append(f"")
        lines.append(f"// Bind directive - add to testbench top")
        lines.append(f"// bind {self.module_name} {self.module_name}_sva sva_inst (.*);")
        
        return "\n".join(lines)


class SVAGenerator:
    """
    Generates SVA assertions from RTL analysis.
    
    This provides MASSIVE value because writing good SVA takes hours/days.
    VerifAI can generate 50+ meaningful assertions in seconds.
    """
    
    def __init__(self, parsed_rtl=None):
        """
        Initialize with parsed RTL from RTLParser.
        
        Args:
            parsed_rtl: ParsedRTL object from rtl_parser.py
        """
        self.parsed_rtl = parsed_rtl
        self.properties: List[SVAProperty] = []
        
    def generate_all(self) -> SVAModule:
        """Generate all applicable assertions based on RTL analysis."""
        if not self.parsed_rtl:
            return SVAModule(module_name="unknown")
        
        module = SVAModule(
            module_name=self.parsed_rtl.module_name,
            clock=self._detect_clock(),
            reset=self._detect_reset(),
            reset_active_low=self._is_reset_active_low()
        )
        
        # Generate assertions by category
        module.properties.extend(self._generate_reset_assertions())
        module.properties.extend(self._generate_stability_assertions())
        module.properties.extend(self._generate_handshake_assertions())
        module.properties.extend(self._generate_protocol_assertions())
        module.properties.extend(self._generate_fsm_assertions())
        module.properties.extend(self._generate_data_integrity_assertions())
        module.properties.extend(self._generate_timing_assertions())
        
        return module
    
    def _detect_clock(self) -> str:
        """Detect main clock signal name."""
        if self.parsed_rtl and self.parsed_rtl.clocks:
            clocks = self.parsed_rtl.clocks.clock_signals
            if clocks:
                return clocks[0]
        # Fallback patterns
        for port in self.parsed_rtl.ports if self.parsed_rtl else []:
            if re.match(r'^(clk|clock|pclk|aclk|sclk|i_clk)$', port.name.lower()):
                return port.name
        return "clk"
    
    def _detect_reset(self) -> str:
        """Detect main reset signal name."""
        if self.parsed_rtl and self.parsed_rtl.clocks:
            resets = self.parsed_rtl.clocks.reset_signals
            if resets:
                return resets[0]
        # Fallback patterns
        for port in self.parsed_rtl.ports if self.parsed_rtl else []:
            if re.match(r'^(rst|reset|rstn|rst_n|presetn|aresetn)$', port.name.lower()):
                return port.name
        return "rst_n"
    
    def _is_reset_active_low(self) -> bool:
        """Detect if reset is active low."""
        reset = self._detect_reset().lower()
        return 'n' in reset or 'neg' in reset or reset.endswith('_l')
    
    def _generate_reset_assertions(self) -> List[SVAProperty]:
        """Generate reset-related assertions."""
        props = []
        reset = self._detect_reset()
        active_low = self._is_reset_active_low()
        reset_cond = f"!{reset}" if active_low else reset
        
        # All outputs should be stable/known after reset
        outputs = [p for p in (self.parsed_rtl.ports if self.parsed_rtl else []) 
                   if p.direction == 'output']
        
        for out in outputs[:5]:  # Limit to avoid too many assertions
            props.append(SVAProperty(
                name=f"reset_{out.name}_known",
                description=f"{out.name} should be known value after reset",
                category=AssertionCategory.RESET,
                assertion_type=AssertionType.ASSERT,
                code=f"@(posedge {self._detect_clock()}) ({reset_cond}) |-> !$isunknown({out.name})"
            ))
        
        # Reset should be asserted at start
        props.append(SVAProperty(
            name="reset_at_start",
            description="Reset should be asserted initially",
            category=AssertionCategory.RESET,
            assertion_type=AssertionType.COVER,
            code=f"@(posedge {self._detect_clock()}) $fell({reset})" if active_low 
                 else f"@(posedge {self._detect_clock()}) $rose({reset})"
        ))
        
        return props
    
    def _generate_stability_assertions(self) -> List[SVAProperty]:
        """Generate signal stability assertions."""
        props = []
        
        # Find potential enable/valid signals
        for port in self.parsed_rtl.ports if self.parsed_rtl else []:
            name_lower = port.name.lower()
            
            # Data should be stable when valid
            if 'data' in name_lower and port.direction == 'output':
                valid_signal = self._find_related_signal(port.name, ['valid', 'vld', 'en'])
                if valid_signal:
                    props.append(SVAProperty(
                        name=f"stable_{port.name}_when_valid",
                        description=f"{port.name} must be stable while {valid_signal} is high",
                        category=AssertionCategory.STABILITY,
                        assertion_type=AssertionType.ASSERT,
                        code=f"@(posedge {self._detect_clock()}) ({valid_signal} && $past({valid_signal})) |-> $stable({port.name})"
                    ))
            
            # Address should be stable during transaction
            if 'addr' in name_lower:
                enable = self._find_related_signal(port.name, ['en', 'sel', 'cs'])
                if enable:
                    props.append(SVAProperty(
                        name=f"stable_{port.name}_during_access",
                        description=f"{port.name} stable during transaction",
                        category=AssertionCategory.STABILITY,
                        assertion_type=AssertionType.ASSERT,
                        code=f"@(posedge {self._detect_clock()}) ({enable} && $past({enable})) |-> $stable({port.name})"
                    ))
        
        return props
    
    def _generate_handshake_assertions(self) -> List[SVAProperty]:
        """Generate request/acknowledge handshake assertions."""
        props = []
        
        # Look for req/ack pairs
        req_signals = []
        ack_signals = []
        valid_signals = []
        ready_signals = []
        
        for port in self.parsed_rtl.ports if self.parsed_rtl else []:
            name_lower = port.name.lower()
            if 'req' in name_lower:
                req_signals.append(port.name)
            if 'ack' in name_lower or 'gnt' in name_lower:
                ack_signals.append(port.name)
            if 'valid' in name_lower or 'vld' in name_lower:
                valid_signals.append(port.name)
            if 'ready' in name_lower or 'rdy' in name_lower:
                ready_signals.append(port.name)
        
        # Req/Ack pairs
        for req in req_signals:
            ack = self._find_matching_signal(req, ack_signals)
            if ack:
                props.append(SVAProperty(
                    name=f"handshake_{req}_eventually_acked",
                    description=f"Request {req} must eventually be acknowledged",
                    category=AssertionCategory.HANDSHAKE,
                    assertion_type=AssertionType.ASSERT,
                    code=f"@(posedge {self._detect_clock()}) $rose({req}) |-> s_eventually({ack})"
                ))
                props.append(SVAProperty(
                    name=f"handshake_no_{ack}_without_{req}",
                    description=f"No acknowledge without prior request",
                    category=AssertionCategory.HANDSHAKE,
                    assertion_type=AssertionType.ASSERT,
                    code=f"@(posedge {self._detect_clock()}) $rose({ack}) |-> $past({req})"
                ))
        
        # Valid/Ready pairs (AXI-style)
        for valid in valid_signals:
            ready = self._find_matching_signal(valid, ready_signals)
            if ready:
                props.append(SVAProperty(
                    name=f"handshake_{valid}_until_accepted",
                    description=f"Valid must stay high until ready",
                    category=AssertionCategory.HANDSHAKE,
                    assertion_type=AssertionType.ASSERT,
                    code=f"@(posedge {self._detect_clock()}) ({valid} && !{ready}) |=> {valid}"
                ))
                props.append(SVAProperty(
                    name=f"cover_handshake_{valid}_{ready}",
                    description=f"Cover successful {valid}/{ready} handshake",
                    category=AssertionCategory.HANDSHAKE,
                    assertion_type=AssertionType.COVER,
                    code=f"@(posedge {self._detect_clock()}) ({valid} && {ready})"
                ))
        
        return props
    
    def _generate_protocol_assertions(self) -> List[SVAProperty]:
        """Generate protocol-specific assertions based on detected protocol."""
        props = []
        
        if not self.parsed_rtl or not self.parsed_rtl.protocol_hints:
            return props
        
        # Get highest confidence protocol
        hints = sorted(self.parsed_rtl.protocol_hints, 
                      key=lambda x: x.confidence, reverse=True)
        
        for hint in hints[:1]:  # Top protocol only
            if hint.protocol == "APB":
                props.extend(self._generate_apb_assertions())
            elif hint.protocol == "AXI":
                props.extend(self._generate_axi_assertions())
            elif hint.protocol == "SPI":
                props.extend(self._generate_spi_assertions())
            elif hint.protocol == "I2C":
                props.extend(self._generate_i2c_assertions())
            elif hint.protocol == "UART":
                props.extend(self._generate_uart_assertions())
        
        return props
    
    def _generate_apb_assertions(self) -> List[SVAProperty]:
        """Generate APB protocol compliance assertions."""
        return [
            SVAProperty(
                name="apb_psel_pready_relationship",
                description="PREADY only valid when PSEL is active",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge pclk) (pready) |-> psel"
            ),
            SVAProperty(
                name="apb_penable_after_psel",
                description="PENABLE must follow PSEL by one cycle",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge pclk) $rose(psel) |=> penable"
            ),
            SVAProperty(
                name="apb_psel_stable_during_transfer",
                description="PSEL stable during transfer",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge pclk) (psel && penable && !pready) |=> psel"
            ),
            SVAProperty(
                name="apb_paddr_stable_during_transfer",
                description="PADDR stable during APB transfer",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge pclk) (psel && penable && !pready) |=> $stable(paddr)"
            ),
            SVAProperty(
                name="apb_pwrite_stable_during_transfer",
                description="PWRITE stable during APB transfer",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge pclk) (psel && penable && !pready) |=> $stable(pwrite)"
            ),
            SVAProperty(
                name="apb_pwdata_stable_during_write",
                description="PWDATA stable during write transfer",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge pclk) (psel && penable && pwrite && !pready) |=> $stable(pwdata)"
            ),
            SVAProperty(
                name="cover_apb_write",
                description="Cover APB write transaction",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(posedge pclk) (psel && penable && pwrite && pready)"
            ),
            SVAProperty(
                name="cover_apb_read",
                description="Cover APB read transaction",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(posedge pclk) (psel && penable && !pwrite && pready)"
            ),
        ]
    
    def _generate_axi_assertions(self) -> List[SVAProperty]:
        """Generate AXI protocol compliance assertions."""
        return [
            SVAProperty(
                name="axi_awvalid_awready_handshake",
                description="Write address channel handshake",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) (awvalid && !awready) |=> awvalid"
            ),
            SVAProperty(
                name="axi_wvalid_wready_handshake",
                description="Write data channel handshake",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) (wvalid && !wready) |=> wvalid"
            ),
            SVAProperty(
                name="axi_arvalid_arready_handshake",
                description="Read address channel handshake",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) (arvalid && !arready) |=> arvalid"
            ),
            SVAProperty(
                name="axi_rvalid_rready_handshake",
                description="Read data channel handshake",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) (rvalid && !rready) |=> rvalid"
            ),
            SVAProperty(
                name="axi_bvalid_bready_handshake",
                description="Write response channel handshake",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) (bvalid && !bready) |=> bvalid"
            ),
            SVAProperty(
                name="axi_stable_awaddr",
                description="Write address stable until handshake",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) (awvalid && !awready) |=> $stable(awaddr)"
            ),
            SVAProperty(
                name="axi_wlast_on_final_beat",
                description="WLAST asserted on final write beat",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(posedge aclk) (wvalid && wready && wlast)"
            ),
            SVAProperty(
                name="axi_no_bresp_without_wlast",
                description="Write response only after final write beat",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge aclk) $rose(bvalid) |-> $past(wlast && wvalid && wready)"
            ),
        ]
    
    def _generate_spi_assertions(self) -> List[SVAProperty]:
        """Generate SPI protocol assertions."""
        return [
            SVAProperty(
                name="spi_miso_valid_on_cs",
                description="MISO valid only when chip select active",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge sclk) (!cs_n) |-> !$isunknown(miso)"
            ),
            SVAProperty(
                name="spi_mosi_stable_on_sample",
                description="MOSI stable at sampling edge",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge sclk) (!cs_n) |-> $stable(mosi)"
            ),
            SVAProperty(
                name="cover_spi_transaction",
                description="Cover complete SPI transaction",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(posedge sclk) ($fell(cs_n) ##[1:100] $rose(cs_n))"
            ),
        ]
    
    def _generate_i2c_assertions(self) -> List[SVAProperty]:
        """Generate I2C protocol assertions."""
        return [
            SVAProperty(
                name="i2c_start_condition",
                description="I2C START: SDA falls while SCL high",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(negedge sda) scl"
            ),
            SVAProperty(
                name="i2c_stop_condition",
                description="I2C STOP: SDA rises while SCL high",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(posedge sda) scl"
            ),
            SVAProperty(
                name="i2c_sda_stable_during_scl_high",
                description="SDA must be stable when SCL is high (except START/STOP)",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge clk) (scl && $past(scl)) |-> $stable(sda)"
            ),
        ]
    
    def _generate_uart_assertions(self) -> List[SVAProperty]:
        """Generate UART protocol assertions."""
        return [
            SVAProperty(
                name="uart_tx_idle_high",
                description="TX line should be high when idle",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge clk) (tx_idle) |-> tx"
            ),
            SVAProperty(
                name="uart_start_bit",
                description="Start bit is always low",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.ASSERT,
                code="@(posedge clk) ($fell(tx) && tx_idle) |=> !tx"
            ),
            SVAProperty(
                name="cover_uart_transmission",
                description="Cover complete UART transmission",
                category=AssertionCategory.PROTOCOL,
                assertion_type=AssertionType.COVER,
                code="@(posedge clk) ($fell(tx) ##[8:12] $rose(tx))"
            ),
        ]
    
    def _generate_fsm_assertions(self) -> List[SVAProperty]:
        """Generate FSM-related assertions."""
        props = []
        
        if not self.parsed_rtl or not self.parsed_rtl.fsm:
            return props
        
        fsm = self.parsed_rtl.fsm
        
        # No illegal states
        if fsm.states:
            states_str = " || ".join([f"({fsm.state_reg} == {s})" for s in fsm.states[:8]])
            props.append(SVAProperty(
                name=f"fsm_{fsm.state_reg}_no_illegal_state",
                description=f"FSM {fsm.state_reg} must be in a valid state",
                category=AssertionCategory.FSM,
                assertion_type=AssertionType.ASSERT,
                code=f"@(posedge {self._detect_clock()}) ({states_str})"
            ))
        
        # Cover all states
        for state in fsm.states[:5]:  # Limit to first 5
            props.append(SVAProperty(
                name=f"cover_fsm_{fsm.state_reg}_{state}",
                description=f"Cover FSM reaching state {state}",
                category=AssertionCategory.FSM,
                assertion_type=AssertionType.COVER,
                code=f"@(posedge {self._detect_clock()}) ({fsm.state_reg} == {state})"
            ))
        
        # Cover transitions
        for i, state in enumerate(fsm.states[:3]):
            if i + 1 < len(fsm.states):
                next_state = fsm.states[i + 1]
                props.append(SVAProperty(
                    name=f"cover_fsm_trans_{state}_to_{next_state}",
                    description=f"Cover transition from {state} to {next_state}",
                    category=AssertionCategory.FSM,
                    assertion_type=AssertionType.COVER,
                    code=f"@(posedge {self._detect_clock()}) ($past({fsm.state_reg}) == {state}) && ({fsm.state_reg} == {next_state})"
                ))
        
        return props
    
    def _generate_data_integrity_assertions(self) -> List[SVAProperty]:
        """Generate data integrity assertions."""
        props = []
        
        # Find data input/output pairs
        data_ins = []
        data_outs = []
        
        for port in self.parsed_rtl.ports if self.parsed_rtl else []:
            if 'data' in port.name.lower() or 'wdata' in port.name.lower():
                if port.direction == 'input':
                    data_ins.append(port.name)
                else:
                    data_outs.append(port.name)
        
        # No X/Z on outputs
        for out in (self.parsed_rtl.ports if self.parsed_rtl else []):
            if out.direction == 'output':
                props.append(SVAProperty(
                    name=f"no_x_on_{out.name}",
                    description=f"No X values on {out.name}",
                    category=AssertionCategory.DATA_INTEGRITY,
                    assertion_type=AssertionType.ASSERT,
                    code=f"@(posedge {self._detect_clock()}) !$isunknown({out.name})",
                    severity="warning"
                ))
                break  # Just one example
        
        return props
    
    def _generate_timing_assertions(self) -> List[SVAProperty]:
        """Generate timing-related assertions."""
        props = []
        
        # Look for enable signals and check response timing
        for port in self.parsed_rtl.ports if self.parsed_rtl else []:
            name_lower = port.name.lower()
            
            if 'en' in name_lower and port.direction == 'input':
                # Response within reasonable time
                done = self._find_related_signal(port.name, ['done', 'ready', 'complete', 'ack'])
                if done:
                    props.append(SVAProperty(
                        name=f"timing_{port.name}_response",
                        description=f"Response within 100 cycles of {port.name}",
                        category=AssertionCategory.TIMING,
                        assertion_type=AssertionType.ASSERT,
                        code=f"@(posedge {self._detect_clock()}) $rose({port.name}) |-> ##[1:100] {done}"
                    ))
        
        return props
    
    def _find_related_signal(self, base_name: str, patterns: List[str]) -> Optional[str]:
        """Find a related signal based on patterns."""
        if not self.parsed_rtl:
            return None
        
        # Extract base without common suffixes
        base = re.sub(r'(data|addr|_i|_o|_in|_out)$', '', base_name.lower())
        
        for port in self.parsed_rtl.ports:
            port_lower = port.name.lower()
            for pattern in patterns:
                if pattern in port_lower:
                    # Check if same prefix
                    port_base = re.sub(r'(valid|vld|en|ready|rdy|_i|_o)$', '', port_lower)
                    if base.startswith(port_base) or port_base.startswith(base) or len(base) == 0:
                        return port.name
        return None
    
    def _find_matching_signal(self, signal: str, candidates: List[str]) -> Optional[str]:
        """Find best matching signal from candidates."""
        signal_base = re.sub(r'(req|ack|valid|ready|vld|rdy|gnt).*$', '', signal.lower())
        
        for cand in candidates:
            cand_base = re.sub(r'(req|ack|valid|ready|vld|rdy|gnt).*$', '', cand.lower())
            if signal_base == cand_base or signal_base in cand_base or cand_base in signal_base:
                return cand
        
        # Return first if no match
        return candidates[0] if candidates else None


def generate_sva_from_rtl(rtl_file: str) -> str:
    """
    Convenience function to generate SVA from an RTL file.
    
    Args:
        rtl_file: Path to Verilog/SystemVerilog file
        
    Returns:
        SystemVerilog code with assertions
    """
    from .rtl_parser import RTLParser
    
    parser = RTLParser()
    with open(rtl_file, 'r') as f:
        content = f.read()
    
    parsed = parser.parse(content)
    generator = SVAGenerator(parsed)
    sva_module = generator.generate_all()
    
    return sva_module.to_sv()


def generate_sva_from_parsed(parsed_rtl) -> str:
    """
    Generate SVA from already-parsed RTL.
    
    Args:
        parsed_rtl: ParsedRTL object
        
    Returns:
        SystemVerilog code with assertions
    """
    generator = SVAGenerator(parsed_rtl)
    sva_module = generator.generate_all()
    return sva_module.to_sv()


# Example usage / CLI
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        sva_code = generate_sva_from_rtl(sys.argv[1])
        print(sva_code)
    else:
        print("Usage: python sva_generator.py <rtl_file.sv>")
